     1                                  ;Kernel for windows
     2                                  ;Version 0.01
     3                                  
     4                                  ;Start of kernel services
     5                                      nanos_version  equ  004h
     6                                  
     7                                  %include 'macro.asm'
     8                              <1> %macro malign 1
     9                              <1>     times (($$-$) % (%1)) db 0  ;even %1 byte
    10                              <1> %endmacro
    11                              <1> 
    12                              <1> %macro calle 1
    13                              <1> 	;Call if equal
    14                              <1> 	jne	%%next
    15                              <1> 	call	%1
    16                              <1> 	jmp	done
    17                              <1> 	%%next:
    18                              <1> %endmacro
    19                              <1> 
    20                              <1>     ;Table register - GDT or LDT depending on which has been selected
    21                              <1> 	%define	d_table		ss:esp
    22                              <1> 	%define	d_table_lim	ss:esp			;2 bytes
    23                              <1> 	%define	d_table_base	ss:esp + 2		;4 bytes
    24                              <1> 
    25                              <1> 	
    26                                  %include '../const.asm'
    27                              <1> global   mem
    28                              <1> 
    29                              <1> ;=========Placement of Loader + Data=============
    30                              <1> memseg   equ  2000h ;start memory: segment
    31                              <1> mem      equ  (memseg * 10h)
    32                              <1> 
    33                              <1> stack_esp   equ 1000h - 4
    34                              <1> 
    35                              <1> IRQBase	equ	20h
    36                              <1> 
    37                              <1> ;Nanos Data Area
    38                              <1> ;Where Nanos places its parameters
    39                              <1> 
    40                              <1> Loader_init: ;Location of data
    41                              <1> .data_end	equ	200h-4	;next segment after loaded data
    42                              <1> 
    43                              <1> 
    44                              <1> 
    45                              <1> 
    46                              <1> Nanos_init:
    47                              <1> ;BIOS memory:
    48                              <1> ;0	old IDT
    49                              <1> ;0	Nanos Data
    50                              <1> .MemSize		equ	0
    51                              <1> .lin_FPT		equ	4
    52                              <1> .lin_FPT_Size	equ	8
    53                              <1> 
    54                              <1> ;400h	BIOS data
    55                              <1> 
    56                                  %include '../mem.asm'
    57                              <1> ;constants
    58                              <1> global lin_kern
    59                              <1> global pages
    60                              <1> extern Kernel_Size
    61                              <1> 
    62                              <1> ;The rest is in pages, Example: lin_PD*pages=linear address to Page Directory
    63                              <1> pages	equ 1000h
    64                              <1> 
    65                              <1> ;Descriptors
    66                              <1> desc_null equ 0   ;Null
    67                              <1> desc_call equ 1   ;Call Gate
    68                              <1> desc_kern equ 2   ;Code(Kernel)
    69                              <1> desc_data equ 3   ;Data(0-4G)
    70                              <1> 
    71                              <1> desc_Idle_TSS equ 4   ;Multitasking TSS
    72                              <1> desc_Stack equ 5   ;Idle TSS Stack
    73                              <1> 
    74                              <1> desc_Mod_LDT	equ 6	;Loader module
    75                              <1> desc_Mod_TSS	equ 7	;Loader module task
    76                              <1> 
    77                              <1> ;Selectors
    78                              <1> null_sel equ (desc_null << 3)
    79                              <1> call_sel equ (desc_call << 3)
    80                              <1> kern_sel equ (desc_kern << 3)
    81                              <1> data_sel equ (desc_data << 3)
    82                              <1> 
    83                              <1> Idle_TSS_sel equ (desc_Idle_TSS << 3)
    84                              <1> Stack_sel	equ (desc_Stack << 3)
    85                              <1> 
    86                              <1> Mod_LDT_sel	equ 6 << 3	;Loader module
    87                              <1> Mod_TSS_sel	equ 7 << 3	;Loader module task
    88                              <1> 
    89                              <1> ;Physical memory
    90                              <1> mem_PD	equ	1
    91                              <1> 
    92                              <1> ;Linear memory
    93                              <1> lin_PT	equ 0
    94                              <1> size_PT	equ 1024 ;PT(1)    All Page tables
    95                              <1> 
    96                              <1> lin_BIOS	equ	lin_PT + size_PT	
    97                              <1> size_BIOS	equ	1
    98                              <1> lin_IDT	equ lin_BIOS + size_BIOS
    99                              <1> size_IDT	equ 1    ;IDT(Actually 0.5 pages)
   100                              <1> lin_TL	equ lin_IDT + size_IDT
   101                              <1> size_TL	equ 1    ;Task List(8192 tasks = 8 pages) 1024 tasks[4Byte] = 1p
   102                              <1> lin_GDT	equ lin_TL+size_TL
   103                              <1> size_GDT	equ 16   ;GDT(1)
   104                              <1> 
   105                              <1> lin_FLM	equ lin_GDT + size_GDT
   106                              <1> size_FLM	equ 1
   107                              <1> 
   108                              <1> lin_Stack	equ lin_FLM + size_FLM		;Kernel Stack
   109                              <1> size_Stack equ 1
   110                              <1> 
   111                              <1> ;Module segments
   112                              <1> ;Stack
   113                              <1> lin_Mod_Stack	equ	lin_Stack+size_Stack
   114                              <1> size_Mod_Stack	equ	1
   115                              <1> ;LDT
   116                              <1> lin_Mod_LDT	equ	lin_Mod_Stack + size_Mod_Stack
   117                              <1> size_Mod_LDT	equ	1
   118                              <1> ;TSS
   119                              <1> lin_Mod_TSS	equ	lin_Mod_LDT + size_Mod_LDT
   120                              <1> size_Mod_TSS	equ	1
   121                              <1> ;Module end
   122                              <1> 
   123                              <1> lin_kern	equ lin_Mod_TSS + size_Mod_TSS
   124                              <1> size_kern	equ Kernel_Size ;Kernel
   125                              <1> 
   126                              <1> lin_FPT	equ lin_kern + size_kern
   127                              <1> ;size_FPT equ System_Mem_FreePT
   128                              <1>              ;Free Page Table(1 Page: 4MB physical)
   129                              <1>              
   130                              <1> lin_Mod_Data	equ	1024 * 2 + 512
   131                                  %include '../struc.asm'
   132                              <1> ;
   133                              <1> ; Nanos Structures
   134                              <1> ;
   135                              <1> 
   136                              <1> ;==============================================================================
   137                              <1> ; BIOS data, Nanos data
   138                              <1> System:
   139                              <1> 	.Base	equ	lin_BIOS * pages
   140                              <1> 	
   141                              <1> 	.old_Interrupt	equ	System.Base +   0
   142                              <1> 	.BIOS_Data	equ	System.Base	+ 400h
   143                              <1> 	.Nanos_Data	equ	System.Base	+ 800h
   144                              <1> 	.Memsize		equ	System.Base	+ Nanos_init.MemSize
   145                              <1> 	.lin_FPT		equ	System.Base	+ Nanos_init.lin_FPT
   146                              <1> 	.lin_FPT_Size	equ	System.Base	+ Nanos_init.lin_FPT_Size
   147                              <1> 	
   148                              <1> 
   149                              <1> ;==============================================================================
   150                              <1> ;Multitasking
   151                              <1> multitasking_struc:
   152                              <1> 	;Task List
   153                              <1> 		.Head		equ	lin_TL * pages
   154                              <1> 		.HeadSize		equ	10h
   155                              <1> 		.Base		equ	.Head + .HeadSize
   156                              <1> 		.Size		equ	size_TL * pages - .HeadSize
   157                              <1> 		.Entry_Size_2	equ  2
   158                              <1> 		.Entry_Size	equ	4 ;bytes
   159                              <1> 
   160                              <1> 	;Header:
   161                              <1> 		.current	equ	0	;4 byte Pointer at current running entry
   162                              <1> 		.last	equ	4	;4 byte Pointer at last entry
   163                              <1> 		.float	equ	8	;2 byte TSS selector of current floating point state owner
   164                              <1> 
   165                              <1> 	;Entry structure:
   166                              <1> 		;.current	equ	0	;2 byte Running TSS	(= interface if not equal Original TSS)
   167                              <1> 		.original	equ	2	;2 byte Original TSS
   168                              <1> 
   169                              <1> 
   170                              <1> ;==============================================================================
   171                              <1> ;Module
   172                              <1> ;	one LDT
   173                              <1> module_struc:	;Module Data(= LDT base & FFFFF000h)
   174                              <1> 	.Name		equ	 0h	;10h bytes
   175                              <1> 	;.free		equ	14h	;Next entry
   176                              <1> 	
   177                              <1> 	.Interface		equ	80h	;Interface List
   178                              <1> 		.InterfaceEntSize	equ	 8h	;Size of structure
   179                              <1> 		.InterfaceEntSize2	equ	 3	;Size of structure 2Log
   180                              <1> 		.InterfaceCount	equ	10h	;number of interfaces
   181                              <1> 		.InterfaceSize		equ	.InterfaceCount * .InterfaceEntSize
   182                              <1> 	
   183                              <1> 	.LDT			equ	.Interface + .InterfaceSize
   184                              <1> 
   185                              <1> ;Interface List
   186                              <1> ; inside Module
   187                              <1> interface_struc:	;Interface entry structure
   188                              <1> 	.Type	equ	0
   189                              <1> 		.Type_present		equ	 1
   190                              <1> 		.Type_in_interface	equ	 2	;otherwise an out interface
   191                              <1> 		.Type_in_reg		equ	 4
   192                              <1> 		.Type_in_float		equ	 8
   193                              <1> 		.Type_in_copy		equ	10h	;Only one of these three
   194                              <1> 		.Type_in_page		equ	20h	; |
   195                              <1> 		.Type_in_desc		equ	30h	; /
   196                              <1> 		.Type_out_reg		equ	40h
   197                              <1> 		.Type_out_float	equ	80h
   198                              <1> 		.Type_Type_map		equ	0FFFFFF00h
   199                              <1> 	
   200                              <1> 	;In:  Connected: Module connected
   201                              <1> 	.Module	equ	4
   202                              <1> 	;Out: Caller(Process), 0 otherwise
   203                              <1> 	.Caller	equ	4
   204                              <1> 		
   205                              <1> 	.TSS		equ	6	;TSS to call/be called
   206                              <1> 	.end		equ	8	;end/Size of entry
   207                              <1> 	
   208                              <1> %if module_struc.InterfaceEntSize != interface_struc.end
   209                              <1> 	%error 'Interface size wrong'
   210                              <1> %endif
   211                              <1> 	
   212                              <1> 	
   213                              <1> ;==============================================================================
   214                              <1> ;Process/Interface (TSS)
   215                              <1> task_struc:
   216                              <1> 	.TSS		equ	0	;TSS Data
   217                              <1> 	.Process	equ	100h	;Process/Interface Data	
   218                              <1> 	.Float	equ	200h	;Float Data
   219                              <1> 	.Stack	equ	400h	;Ring 0 Stack Data(descriptor in LDT)	
   220                              <1> 	.StackSize equ pages - .Stack
   221                              <1> 	;1000h	(next page)
   222                              <1> 	
   223                              <1> ;Process/Interface Data(100h bytes)
   224                              <1> 	.Name	equ	.Process + 0	;Name
   225                              <1> 	.Runtime	equ	.Process + 10h	;Runtime
   226                              <1> 	.Forward	equ	.Process + 18h	;Forward link(interface called)
   227                              <1> 
   228                              <1> ;==============================================================================
   229                              <1> ;TSS/Data Descriptor:
   230                              <1> ;Available bit:
   231                              <1> 	;0 process(ordinary)
   232                              <1> 	;1 interface Task/Data - only removed by interface kernel code
   233                              <1> 		
   234                              <1> 
   235                              <1> ;==============================================================================
   236                              <1> ;Paging Structures
   237                              <1> 
   238                              <1> Paging:
   239                              <1> %define	Paging_Base	equ	[System.lin_FPT]		;dword with pointer to start of FPT
   240                              <1> %define	Paging_Size	equ	[System.lin_FPT_Size]
   241                              <1> 
   242                              <1> 	
   243                                  %include 'err_code.asm'
   244                              <1> err_no_service     equ  -1
   245                              <1> 
   246                              <1> err_table_full     equ  45 ;No free selector
   247                              <1> err_table_bounds   equ  46 ;Specified selector is outside table bounds
   248                              <1> 
   249                              <1> err_page_descriptor equ	62   ;Descriptor is not a Data descriptor(Data Code LDT TSS)
   250                              <1> err_page_limit		equ  63   ;Pages dont fit into descriptor
   251                              <1> err_page_outofmemory equ 64	;No free pages left
   252                              <1> 
   253                              <1> err_TL_Full	 	equ	80	;Task list is full, can't add entry
   254                              <1> err_TL_NotFound 	equ	81	;Task list is full, can't add entry
   255                              <1> 
   256                              <1> 
   257                              <1> 
   258                                  
   259                                  
   260                                  SEGMENT .text
   261                                  
   262                                  kernel_start:
   263                                  ;Startup code
   264 00000000 FB                      sti
   265                                  
   266                                  %include 'rs232.asm'
   267                              <1> ;
   268                              <1> ;RS232 Interface macros
   269                              <1> ;To be used for debugging
   270                              <1> ;
   271                              <1> ;Written by Peter Hultqvist, peter.hultqvist@neocoder.net
   272                              <1> ;
   273                              <1> 
   274                              <1> ;Port Base Addresses*
   275                              <1> ;Port1	3F8h
   276                              <1> ;Port2	2F8h
   277                              <1> ;Port3	3E8h
   278                              <1> ;Port4	2E8h
   279                              <1> ;
   280                              <1> ;	*Base addresses may be different on different computers
   281                              <1> RS232:
   282                              <1> 
   283                              <1> RS232_Base	equ	3F8h
   284                              <1> 
   285                              <1> ;DLAB=0
   286                              <1> RS232_Data	equ	0
   287                              <1> RS232_Interrupt_Enable	equ	1
   288                              <1> RS232_Interrupt_ID	equ	2
   289                              <1> RS232_FIFO_Control	equ	2
   290                              <1> 
   291                              <1> ;DLAB=1
   292                              <1> RS232_DivisorLSB	equ	0
   293                              <1> RS232_DivisorMSB	equ	1
   294                              <1> RS232_Alternate_Function	equ	2
   295                              <1> 
   296                              <1> RS232_Line_Control	equ	3
   297                              <1> RS232_Modem_Control	equ	4
   298                              <1> RS232_Line_Status	equ	5
   299                              <1> RS232_Modem_Status	equ	6
   300                              <1> RS232_Scratch_Pad	equ	7
   301                              <1> 
   302                              <1> ;Init code
   303 00000001 60                  <1> pusha
   304                              <1> 	;Initiate RS232
   305                              <1> 		;Set DLAB = 0
   306 00000002 66BAFB03            <1> 		mov	dx, RS232_Base + RS232_Line_Control
   307 00000006 B000                <1> 		mov	al, 0
   308 00000008 EE                  <1> 		out	dx, al
   309                              <1> 
   310                              <1> 		;Disable Interrupts
   311 00000009 66BAF903            <1> 		mov	dx, RS232_Base + RS232_Interrupt_Enable
   312 0000000D B000                <1> 		mov	al, 0
   313 0000000F EE                  <1> 		out	dx, al
   314                              <1> 
   315                              <1> 		;Set DLAB = 1
   316 00000010 66BAFB03            <1> 		mov	dx, RS232_Base + RS232_Line_Control
   317 00000014 B080                <1> 		mov	al, 80h
   318 00000016 EE                  <1> 		out	dx, al
   319                              <1> 		
   320                              <1> 		;Set Baud Rate
   321 00000017 66BAF803            <1> 		mov	dx, RS232_Base + RS232_DivisorLSB
   322 0000001B B00C                <1> 		mov	al, 0Ch	;9600 kbps
   323 0000001D EE                  <1> 		out	dx, al
   324 0000001E 6642                <1> 		inc	dx
   325 00000020 B000                <1> 		mov	al, 0
   326 00000022 EE                  <1> 		out	dx, al
   327                              <1> 
   328                              <1> 		;Set DLAB = 0, + Line Control
   329 00000023 66BAFB03            <1> 		mov	dx, RS232_Base + RS232_Line_Control
   330 00000027 B003                <1> 		mov	al, 3	;8 bits, no parity, 1 stop
   331 00000029 EE                  <1> 		out	dx, al
   332                              <1> 		
   333                              <1> 		;Disable FIFO
   334 0000002A 66BAFA03            <1> 		mov	dx, RS232_Base + RS232_FIFO_Control
   335 0000002E B000                <1> 		mov	al, 0
   336 00000030 EE                  <1> 		out	dx, al
   337 00000031 61                  <1> 	popa
   338                              <1> 
   339 00000032 E968000000          <1> 	jmp	.end
   340                              <1> 
   341                              <1> %macro Print 1
   342                              <1> 	pusha
   343                              <1> 	mov	edx, %1
   344                              <1> 	call RS232.Print
   345                              <1> 	popa
   346                              <1> %endmacro
   347                              <1> 
   348                              <1> .Print:
   349                              <1> 	.print_loop:
   350 00000037 8A02                <1> 	mov	al, [edx]
   351 00000039 3C00                <1> 	cmp	al, 0
   352 0000003B 7408                <1> 	je	.print_done
   353 0000003D E804000000          <1> 	call	.PrintByte
   354 00000042 42                  <1> 	inc	edx
   355 00000043 EBF2                <1> 	jmp	.print_loop
   356                              <1> 	
   357                              <1> 	.print_done
   358 00000045 C3                  <1> 	ret
   359                              <1> 
   360                              <1> %macro PrintByte 1
   361                              <1> 	pusha
   362                              <1> 	mov	al, %1
   363                              <1> 	call RS232.PrintByte
   364                              <1> 	popa
   365                              <1> %endmacro
   366                              <1> 
   367                              <1> .PrintByte:
   368 00000046 60                  <1> 	pusha
   369                              <1> 	;al = byte to send/print
   370                              <1> 	;RS232
   371 00000047 88C4                <1> 		mov	ah, al
   372                              <1> 		;test if ready to send
   373 00000049 66BAFD03            <1> 		mov	dx, RS232_Base + RS232_Line_Status
   374 0000004D 66B9FFFF            <1> 		mov	cx, 0FFFFh
   375                              <1> 		.ready_to_send:
   376 00000051 EC                  <1> 			in	al, dx
   377 00000052 660FBAE005          <1> 			bt	ax, 5
   378 00000057 7202                <1> 			jc	.ready
   379 00000059 E2F6                <1> 		loop	.ready_to_send
   380                              <1> 		
   381                              <1> 		.ready
   382                              <1> 		;send byte
   383 0000005B 88E0                <1> 		mov	al, ah
   384 0000005D 66BAF803            <1> 		mov	dx, RS232_Base + RS232_Data
   385 00000061 EE                  <1> 		out	dx, al
   386 00000062 61                  <1> 	popa
   387 00000063 C3                  <1> 	ret
   388                              <1> 
   389                              <1> 
   390                              <1> %macro PrintHex 2
   391                              <1> 	pusha
   392                              <1> 	mov	eax, %1	
   393                              <1> 	mov	ecx, %2
   394                              <1> 	call RS232.PrintHex
   395                              <1> 	popa
   396                              <1> %endmacro
   397                              <1> 
   398                              <1> .PrintHex:
   399                              <1> 	;Print a number in hex
   400                              <1> 	;in:	eax = number to be written
   401                              <1> 	;	ecx = number of nibbles(hex number)(1 to 8)
   402                              <1> 	
   403 00000064 89C2                <1> 	mov	edx, eax
   404                              <1> 	
   405 00000066 C1E102              <1> 	shl	ecx, 2
   406 00000069 D3CA                <1> 	ror	edx, cl
   407 0000006B C1E902              <1> 	shr	ecx, 2
   408                              <1> 	
   409                              <1> 	
   410                              <1> 		
   411                              <1> 	.hex_loop:
   412 0000006E C1C204              <1> 		rol	edx, 4
   413                              <1> 	
   414 00000071 88D0                <1> 		mov	al, dl
   415 00000073 240F                <1> 		and	al, 0Fh
   416                              <1> 
   417 00000075 3C0A                <1> 		cmp	al, 10
   418 00000077 0F92C4              <1> 		setb	ah
   419 0000007A FECC                <1> 		dec	ah
   420 0000007C 80E407              <1> 		and	ah, 'A'-'0' -10		
   421 0000007F 80C430              <1> 		add	ah, '0'
   422 00000082 00E0                <1> 		add	al, ah
   423 00000084 E8BDFFFFFF          <1> 		call	.PrintByte
   424                              <1> 		
   425 00000089 E2E3                <1> 		loop	.hex_loop
   426 0000008B C3                  <1> 	ret
   427                              <1> 	
   428                              <1> 	
   429                              <1> %macro PrintBin 2
   430                              <1> 	pusha
   431                              <1> 	mov	eax, %1	
   432                              <1> 	mov	ecx, %2
   433                              <1> 	call RS232.PrintBin
   434                              <1> 	popa
   435                              <1> %endmacro
   436                              <1> 	
   437                              <1> .PrintBin:
   438                              <1> 	;Print a number in binary
   439                              <1> 	;in:	eax = number to be written
   440                              <1> 	;	ecx = number of bits(1 to 32)
   441 0000008C 89C2                <1> 	mov	edx, eax
   442 0000008E D3CA                <1> 	ror	edx, cl
   443                              <1> 	
   444                              <1> 	.bin_loop:
   445 00000090 D1D2                <1> 		rcl	edx, 1	
   446                              <1> 		
   447 00000092 0F92C0              <1> 		setc	al
   448 00000095 0430                <1> 		add	al, '0'
   449 00000097 E8AAFFFFFF          <1> 		call	.PrintByte
   450                              <1> 		
   451 0000009C E2F2                <1> 		loop	.bin_loop
   452                              <1> 	
   453 0000009E C3                  <1> 	ret
   454                              <1> 
   455                              <1> .end:
   456                                  
   457                                  PrintByte '-'
   458 0000009F 60                  <1>  pusha
   459 000000A0 B02D                <1>  mov al, %1
   460 000000A2 E89FFFFFFF          <1>  call RS232.PrintByte
   461 000000A7 61                  <1>  popa
   462                                  PrintByte 'K'
   463 000000A8 60                  <1>  pusha
   464 000000A9 B04B                <1>  mov al, %1
   465 000000AB E896FFFFFF          <1>  call RS232.PrintByte
   466 000000B0 61                  <1>  popa
   467                                  PrintByte 'e'
   468 000000B1 60                  <1>  pusha
   469 000000B2 B065                <1>  mov al, %1
   470 000000B4 E88DFFFFFF          <1>  call RS232.PrintByte
   471 000000B9 61                  <1>  popa
   472                                  PrintByte 'r'
   473 000000BA 60                  <1>  pusha
   474 000000BB B072                <1>  mov al, %1
   475 000000BD E884FFFFFF          <1>  call RS232.PrintByte
   476 000000C2 61                  <1>  popa
   477                                  PrintByte 'n'
   478 000000C3 60                  <1>  pusha
   479 000000C4 B06E                <1>  mov al, %1
   480 000000C6 E87BFFFFFF          <1>  call RS232.PrintByte
   481 000000CB 61                  <1>  popa
   482                                  PrintByte 'e'
   483 000000CC 60                  <1>  pusha
   484 000000CD B065                <1>  mov al, %1
   485 000000CF E872FFFFFF          <1>  call RS232.PrintByte
   486 000000D4 61                  <1>  popa
   487                                  PrintByte 'l'
   488 000000D5 60                  <1>  pusha
   489 000000D6 B06C                <1>  mov al, %1
   490 000000D8 E869FFFFFF          <1>  call RS232.PrintByte
   491 000000DD 61                  <1>  popa
   492                                  PrintByte '-'
   493 000000DE 60                  <1>  pusha
   494 000000DF B02D                <1>  mov al, %1
   495 000000E1 E860FFFFFF          <1>  call RS232.PrintByte
   496 000000E6 61                  <1>  popa
   497                                  
   498                                  ;jump to idle task
   499 000000E7 E940110000              jmp	Multitasking.idle
   500                                  
   501                                  
   502                                  ;Kernel services
   503                                  global	service
   504                                  %include 'service.asm'
   505                              <1> ;===========================================
   506                              <1> ; Services
   507                              <1> ;
   508                              <1> ; Converts C calling to kernel service
   509                              <1> ; Preserve: EBP, EBX, ESI, EDI
   510                              <1> ;
   511                              <1> ; Stack:
   512                              <1> ;	ebp +  0	ebp
   513                              <1> ;	ebp +  4	eip	
   514                              <1> ;	ebp +  8	cs
   515                              <1> ;	ebp +  C	Service number	
   516                              <1> ;	ebp + 10	param 1
   517                              <1> 
   518                              <1> %define	old_ebp		ss:ebp
   519                              <1> %define	caller_ds		ss:ebp + 4
   520                              <1> %define	caller_eip	ss:ebp + 8	;Callers EIP
   521                              <1> %define	caller_cs 	ss:ebp + 12	;Callers CS
   522                              <1> 
   523                              <1> 
   524                              <1> service:
   525 000000EC 1E                  <1> 	push	ds
   526 000000ED 55                  <1> 	push	ebp
   527 000000EE 89E5                <1> 	mov	ebp, esp
   528                              <1> 		
   529                              <1> 	;fix ds
   530 000000F0 6818000000          <1> 	push	data_sel
   531 000000F5 1F                  <1> 	pop	ds
   532                              <1> 
   533                              <1> 	;eax = service number
   534 000000F6 253F000000          <1> 	and	eax, 03Fh		;40h services
   535 000000FB C1E002              <1> 	shl	eax, 2
   536 000000FE 05[10010000]        <1> 	add	eax, .list
   537 00000103 2EFF10              <1> 	call	[cs:eax]
   538                              <1> 		
   539 00000106 5D                  <1> 	pop	ebp
   540 00000107 1F                  <1> 	pop	ds
   541 00000108 CB                  <1> 	retf
   542                              <1> 	
   543                              <1> .no_service:
   544                              <1> 	;wrong Service number
   545 00000109 B8FFFFFFFF          <1> 	mov	eax, err_no_service
   546 0000010E F9                  <1> 	stc
   547 0000010F C3                  <1> 	ret
   548                              <1> 	
   549                              <1> align 4
   550                              <1> 		
   551                              <1> .list: ;Service number
   552                              <1> ;00		;OS specific
   553 00000110 [10020000]          <1> 	dd	sys.version		;(eax = Version) == ()
   554 00000114 [09010000]          <1> 	dd		.no_service
   555 00000118 [09010000]          <1> 	dd		.no_service
   556 0000011C [09010000]          <1> 	dd		.no_service
   557 00000120 [38070000]          <1> 	dd	page.freemem		;(eax Free memory) == ()
   558 00000124 [09010000]          <1> 	dd		.no_service
   559 00000128 [09010000]          <1> 	dd		.no_service
   560 0000012C [09010000]          <1> 	dd		.no_service
   561                              <1> ;08		System services
   562 00000130 [09010000]          <1> 	dd		.no_service
   563 00000134 [09010000]          <1> 	dd		.no_service
   564 00000138 [09010000]          <1> 	dd		.no_service
   565 0000013C [09010000]          <1> 	dd		.no_service	;connect IRQ to interface
   566 00000140 [09010000]          <1> 	dd		.no_service	;DMA
   567 00000144 [09010000]          <1> 	dd		.no_service	;PIC/APIC
   568 00000148 [09010000]          <1> 	dd		.no_service
   569 0000014C [09010000]          <1> 	dd		.no_service
   570                              <1> ;10		Module management
   571 00000150 [790F0000]          <1> 	dd	module.create		;(eax Selector) == (ecx LDT Size)
   572 00000154 [21100000]          <1> 	dd	module.delete		;() == (edx Selector)
   573 00000158 [09010000]          <1> 	dd		.no_service	;get settings
   574 0000015C [09010000]          <1> 	dd		.no_service	;set settings
   575 00000160 [B4100000]          <1> 	dd	module.move		;(eax Selector) == (edx Source selector, ebx Target [module][selector])
   576 00000164 [ED100000]          <1> 	dd	module.movetask	;() == (edx Source Task selector, ebx Target Module)
   577 00000168 [09010000]          <1> 	dd		.no_service	
   578 0000016C [09010000]          <1> 	dd		.no_service
   579                              <1> ;18 +	Unknown
   580 00000170 [09010000]          <1> 	dd		.no_service
   581 00000174 [23110000]          <1> 	dd	life	;return meaning of life in eax
   582 00000178 [09010000]          <1> 	dd		.no_service
   583 0000017C [09010000]          <1> 	dd		.no_service
   584 00000180 [09010000]          <1> 	dd		.no_service
   585 00000184 [09010000]          <1> 	dd		.no_service
   586 00000188 [09010000]          <1> 	dd		.no_service
   587 0000018C [09010000]          <1> 	dd		.no_service
   588                              <1> ;20 +	Descriptors, Linear memory
   589 00000190 [49020000]          <1> 	dd	desc.create_data		;(eax = Selector) == (edx [Settings][Selector], ecx Size)
   590 00000194 [97030000]          <1> 	dd	desc.delete			;(eax Status) == (edx Selector)
   591 00000198 [09010000]          <1> 	dd		.no_service
   592 0000019C [09010000]          <1> 	dd		.no_service
   593 000001A0 [D4020000]          <1> 	dd	desc.get				;(eax [Settings][Selector]) == (edx Selector)
   594 000001A4 [EE020000]          <1> 	dd	desc.set				;() == (edx [Settings][Selector])
   595 000001A8 [09010000]          <1> 	dd		.no_service
   596 000001AC [09010000]          <1> 	dd		.no_service
   597                              <1> ;28 +	Paging, Physical memory
   598 000001B0 [47070000]          <1> 	dd	page.alloc		;() == (edx = [Settings][Selector], ebx = Base, ecx = Size)
   599 000001B4 [0F080000]          <1> 	dd	page.dealloc		;() == (edx = Selector, ebx = Base, ecx = Size)
   600 000001B8 [09010000]          <1> 	dd		.no_service
   601 000001BC [09010000]          <1> 	dd		.no_service
   602 000001C0 [09010000]          <1> 	dd		.no_service	;get phys address
   603 000001C4 [09010000]          <1> 	dd		.no_service
   604 000001C8 [73090000]          <1> 	dd	page.phys_allocate		;() == (edx Selector, ebx Base, edi First PTE, ecx Size)
   605 000001CC [09010000]          <1> 	dd		.no_service	;
   606                              <1> ;30 +	Multitasking
   607 000001D0 [DA090000]          <1> 	dd	mult.create		;(eax = Selector) == ()
   608 000001D4 [950A0000]          <1> 	dd	mult.delete		;() == (edx Selector)
   609 000001D8 [E10A0000]          <1> 	dd	mult.get			;() == (edx TSS Selector, ds:ebx TSS segment data)
   610 000001DC [C10B0000]          <1> 	dd	mult.set			;() == (edx TSS Selector, ds:ebx TSS segment data)
   611 000001E0 [AD0C0000]          <1> 	dd	mult.add			;() == (dx = TSS Selector)
   612 000001E4 [F80C0000]          <1> 	dd	mult.remove		;(eax Status) == (edx = TSS Selector)
   613 000001E8 [09010000]          <1> 	dd		.no_service
   614 000001EC [09010000]          <1> 	dd		.no_service	
   615                              <1> ;38 +	Interface
   616 000001F0 [990D0000]          <1> 	dd	interface.create	;() == (edx Type, ebx Process(TSS selector))
   617 000001F4 [160E0000]          <1> 	dd	interface.delete	;() == (edx Type)
   618 000001F8 [2B0F0000]          <1> 	dd	interface.call		;() == (edx Type)
   619 000001FC [09010000]          <1> 	dd		.no_service	;Get param
   620 00000200 [670E0000]          <1> 	dd	interface.connect	;() == (edx Type, ebx [source][target] module)
   621 00000204 [09010000]          <1> 	dd		.no_service	;Disconnect interface
   622 00000208 [09010000]          <1> 	dd		.no_service
   623 0000020C [09010000]          <1> 	dd		.no_service	;Abort interface
   624                              <1> 	
   625                              <1> .list_end:
   626                              <1> 
   627                              <1> 	;.list must be 256 bytes
   628                              <1> 	.list_size equ 100h
   629                              <1> 	times (.list_end-.list) - .list_size	dd 0	;List is too small
   630                              <1> 	times .list_size - (.list_end-.list)	dd 0 ;List is too big
   631                              <1> 
   632                              <1> %include 'sys.asm'
   633                              <2> sys:
   634                              <2> 
   635                              <2> ;===============================================================================
   636                              <2> 
   637                              <2> ;sys.version	;(eax = Version) == ()
   638                              <2> 
   639                              <2> .version:
   640 00000210 B804000000          <2>     mov  eax, nanos_version
   641 00000215 F8                  <2>     clc
   642 00000216 C3                  <2>     ret
   643                              <2> 
   644                              <2>     
   645                              <2> 
   646                              <2> ;===============================================================================
   647                              <2> ;
   648                              <2> ;system.interrupt	;(eax = Interrupt) == (int Interrupt, int Selector, int Offset)
   649                              <2> ;	Create a Interrupt Gate
   650                              <2> 
   651                              <2> ; .interrupt
   652                              <2> ; 	push edx
   653                              <2> ; 	
   654                              <2> ; 		;Check Privileges
   655                              <2> ; 		mov	ax, [caller_cs]
   656                              <2> ;		movzx edx, word [param2]
   657                              <2> ; 		arpl	dx, ax
   658                              <2> ; 		
   659                              <2> ; 		lar	edx, edx
   660                              <2> ; 		jnz	.interrupt_error		;Privilege check failed
   661                              <2> ; 		shr	edx, 8
   662                              <2> ; 		and	edx, 18h
   663                              <2> ; 		cmp	edx, 18h
   664                              <2> ; 		jne	.interrupt_error		;Not a Code segment
   665                              <2> ;
   666                              <2> ; 		;Check Interrupt
   667                              <2> ;		mov	edx, [param1]
   668                              <2> ; 		and	edx, 0FFh
   669                              <2> ; 		shl	edx, 3
   670                              <2> ; 		add	edx, lin_IDT * pages
   671                              <2> ; 		bts dword [edx + 4], 15
   672                              <2> ; 		jc	.interrupt_error		;Interrupt already taken
   673                              <2> ;
   674                              <2> ; 		;Write descriptor
   675                              <2> ; 		;Int.Gate    [Offset      16]1Pl0S110[------][Selector      ][Offset       0]
   676                              <2> ;		mov	eax, [param3]
   677                              <2> ; 		mov	[edx], ax
   678                              <2> ; 		shr	eax, 10h
   679                              <2> ; 		mov	[edx + 6], ax
   680                              <2> ; 		mov	eax, 8E000000h
   681                              <2> ;		mov	ax, [param2]
   682                              <2> ; 		mov	[edx + 2], eax
   683                              <2> ;
   684                              <2> ; 		;Done
   685                              <2> ;		mov	eax, [param1]
   686                              <2> ; 		and	eax, 0FFh
   687                              <2> ; 	pop	edx
   688                              <2> ; 	clc
   689                              <2> ; 	ret
   690                              <2> ; 						
   691                              <2> ; 	.interrupt_error:
   692                              <2> ; 	xor	eax, eax
   693                              <2> ; 	pop	edx
   694                              <2> ; 	stc
   695                              <2> ; 	ret	
   696                              <2> 
   697                              <2> 	
   698                              <2> ;===============================================================================
   699                              <2> ;
   700                              <2> ;system.delete_interrupt	;(eax = Error code) == (int Interrupt)
   701                              <2> ;	Delete a Interrupt Gate
   702                              <2> ;
   703                              <2> 
   704                              <2> ; .delete_interrupt
   705                              <2> ; 	push edx
   706                              <2> ; 	
   707                              <2> ; 		;Check Privileges
   708                              <2> ; 		mov	ax, [caller_cs]
   709                              <2> ; 		mov	dx, 0
   710                              <2> ; 		arpl	ax, dx				;only privilege 0 may remove a interrupt gate
   711                              <2> ; 		jz	.delete_interrupt_error
   712                              <2> ; 		
   713                              <2> ; 		;Remove interrupt
   714                              <2> ; 		mov	edx, [param1]
   715                              <2> ; 		and	edx, 0FFh
   716                              <2> ; 		shl	edx, 3
   717                              <2> ; 		add	edx, lin_IDT * pages
   718                              <2> 
   719                              <2> ; 		;Write descriptor
   720                              <2> ; 		mov	[edx], dword 0
   721                              <2> ; 		mov	[edx + 4], dword 0
   722                              <2> 
   723                              <2> ; 		;Done
   724                              <2> ; 		mov	eax, 0
   725                              <2> ; 	pop	edx
   726                              <2> ; 	clc
   727                              <2> ; 	ret
   728                              <2> ; 						
   729                              <2> ; 	.delete_interrupt_error:
   730                              <2> ; 	mov	eax, -1
   731                              <2> ; 	pop	edx
   732                              <2> ; 	stc
   733                              <2> ; 	ret	
   734                              <1> %include 'sysm.asm'
   735                              <2> sysm:
   736                              <2> 
   737                              <2> 	
   738                              <2> 	
   739                              <2> ;===============================================================================
   740                              <2> ;
   741                              <2> ;	sysm.create_callgate	;(eax = Selector) == (int CallG selector, int Target selector, int offset, int DWord count)
   742                              <2> ;	Create a CallGate
   743                              <2> ;
   744                              <2> ;	In:
   745                              <2> ;		param1	Selector for CallGate
   746                              <2> ;		param2	Selector for Target
   747                              <2> ;		param3	Offset
   748                              <2> ;		param4	Dword count
   749                              <2> ;	Out:
   750                              <2> ;		int		Selector
   751                              <2> 
   752                              <2> ;.create_callgate:
   753                              <2> ; 	push	ecx
   754                              <2> ; 	push edx
   755                              <2> ; 	
   756                              <2> ; 		;Check Privileges
   757                              <2> ; 		mov	ax, [caller_cs]
   758                              <2> ; 		arpl	[param1], ax
   759                              <2> ; 		arpl	[param2], ax
   760                              <2> ; 		jz	.call_error	;Error: DPL < CPL
   761                              <2> ; 		
   762                              <2> ; 		lar	edx, edx
   763                              <2> ; 		jnz	.call_error		;Privilege check failed
   764                              <2> ; 		shr	edx, 8
   765                              <2> ; 		and	edx, 18h
   766                              <2> ; 		cmp	edx, 10h
   767                              <2> ; 		jne	.call_error		;Not a Code segment
   768                              <2> 
   769                              <2> ; 		mov	eax, [param1]
   770                              <2> ; 		mov	edx, [param3]
   771                              <2> ; 		mov	ecx, [param4]
   772                              <2> ; 		and	ecx, 1Fh
   773                              <2> ; 		or	ecx, 8C00h
   774                              <2> ; 		shl	ecx, 10h
   775                              <2> ; 		mov	cx, [param2]
   776                              <2> ; 		call	.gate	;(same, eax = selector)==(eax = descriptor selector, edx = offset, ecx = settings+target selector)
   777                              <2> ; 					;CallGate    [Offset      16]1Pl0S100[-][Dwc][Selector      ][Offset       0]
   778                              <2> ; 		jc	.call_error
   779                              <2> ; 	
   780                              <2> ; 	pop	edx
   781                              <2> ; 	pop	ecx
   782                              <2> ; 	clc
   783                              <2> ; 	ret
   784                              <2> ; 						
   785                              <2> ; 	.call_error:
   786                              <2> ; 	xor	eax, eax
   787                              <2> ; 	pop	edx
   788                              <2> ; 	pop	ecx
   789                              <2> ; 	stc
   790                              <2> ; 	ret		
   791                              <2> 		
   792                              <2> 
   793                              <2> ;===============================================================================
   794                              <2> ;
   795                              <2> ;	sysm.gate	;(same, eax = selector)==(eax = descriptor selector, edx = offset, ecx = settings+target selector)
   796                              <2> ;TaskGate    [--------------]1Pl00101[------][Selector      ][--------------]
   797                              <2> ;CallGate    [Offset      16]1Pl0S100[-][Dwc][Selector      ][Offset       0]
   798                              <2> ;Int.Gate    [Offset      16]1Pl0S110[------][Selector      ][Offset       0]
   799                              <2> ;TrapGate    [Offset      16]1Pl0S111[------][Selector      ][Offset       0]
   800                              <2> 
   801                              <2> .gate
   802 00000217 51                  <2> 	push	ecx
   803 00000218 52                  <2> 	push	edx
   804                              <2> 		
   805 00000219 C1C103              <2> 		rol	ecx, 3
   806 0000021C 63C1                <2> 		arpl cx, ax
   807 0000021E C1C903              <2> 		ror	ecx, 3
   808 00000221 81E1FFFF1FEF        <2> 		and	ecx, 0EF1FFFFFh
   809 00000227 81C900000084        <2> 		or	ecx,  84000000h
   810                              <2> 		
   811                              <2> 		;Create Descriptor
   812                              <2> 		
   813 0000022D E8FA000000          <2> 		call	desc.create_desc	;(eax = selector, ebx = Desc Base) == (eax = selector)
   814 00000232 7211                <2> 		jc	.gate_error
   815                              <2> 
   816                              <2> 		;Write data to descriptor
   817 00000234 894B02              <2> 		mov	[ebx + 2], ecx		;Selector, settings, Dword(CallGate)
   818 00000237 668913              <2> 		mov	[ebx], dx			;Offset
   819 0000023A C1EA10              <2> 		shr	edx, 10h
   820 0000023D 66895306            <2> 		mov	[ebx + 6], dx
   821                              <2> 			
   822                              <2> 		;Done
   823                              <2> 		
   824 00000241 5A                  <2> 	pop	edx
   825 00000242 59                  <2> 	pop	ecx
   826 00000243 F8                  <2> 	clc
   827 00000244 C3                  <2> 	ret
   828                              <2> 	
   829                              <2> 	.gate_error:
   830 00000245 5A                  <2> 	pop	edx
   831 00000246 59                  <2> 	pop	ecx
   832 00000247 F9                  <2> 	stc
   833 00000248 C3                  <2> 	ret
   834                              <2> 	
   835                              <2> 		
   836                              <1> %include 'desc.asm'
   837                              <2> desc:
   838                              <2> 
   839                              <2> ;===============================================================================
   840                              <2> ;
   841                              <2> ;	desc.create_data		(eax = Selector) == (edx [Settings][Selector], ecx Size)
   842                              <2> 
   843                              <2> 	;Create a Data/Code Segment
   844                              <2> 	
   845                              <2> 	;Selector
   846                              <2> 		;bit0:1 = DPL
   847                              <2> 		;bit2 = ti, 0:GDT 1:LDT
   848                              <2> 		;bit3-15 = selector, 0 = any selector
   849                              <2> 	;Size(in bytes) - Granulary bit is fixed automatically
   850                              <2> 	;Settings
   851                              <2> 		;Data        0EWA
   852                              <2> 		;Code        1CRA
   853                              <2> 
   854                              <2> .create_data:
   855                              <2> 
   856                              <2> 	;Check Privileges
   857 00000249 36668B450C          <2> 	mov	ax, [caller_cs]
   858 0000024E 63C2                <2> 	arpl	dx, ax
   859                              <2> 	
   860                              <2> 	;Make Settings
   861 00000250 6689D0              <2> 	mov	ax, dx
   862 00000253 66250300            <2> 	and	ax, 3	;keep DPL
   863 00000257 66C1E005            <2> 	shl	ax, 5
   864 0000025B 660D9040            <2> 	or	ax, 4090h		;Default 32, Present bit, Data/Code descriptor
   865 0000025F C1E010              <2> 	shl	eax, 10h
   866 00000262 09D0                <2> 	or	eax, edx
   867 00000264 25FFFFFF40          <2> 	and	eax, 40FFFFFFh	;safe settings
   868                              <2> 	;eax = [Settings | Selector]
   869                              <2> 	
   870 00000269 53                  <2> 	push	ebx
   871 0000026A 51                  <2> 	push	ecx	
   872 0000026B 52                  <2> 	push	edx
   873                              <2> 	
   874                              <2> 		;ecx = Size
   875 0000026C E80B000000          <2> 		call desc.create	;(eax Selector, edx = Segment Base, ebx = Desc Base) == (eax [Settings][Selector], ecx Size)
   876 00000271 7204                <2> 		jc	.create_data_error
   877                              <2> 	
   878 00000273 5A                  <2> 	pop	edx
   879 00000274 59                  <2> 	pop	ecx
   880 00000275 5B                  <2> 	pop	ebx
   881                              <2> 	
   882 00000276 C3                  <2> 	ret
   883                              <2> 	
   884                              <2> 		.create_data_error:
   885 00000277 5A                  <2> 	pop	edx
   886 00000278 59                  <2> 	pop	ecx
   887 00000279 5B                  <2> 	pop	ebx
   888 0000027A F9                  <2> 	stc
   889 0000027B C3                  <2> 	ret
   890                              <2> 
   891                              <2> ;===============================================================================
   892                              <2> 
   893                              <2> ;desc.create	;(eax Selector, edx = Segment Base, ebx = Desc Base) == (eax [Settings][Selector], ecx Size)
   894                              <2> 
   895                              <2> ;Create a data/code/LDT/TSS descriptor
   896                              <2> 
   897                              <2> .create:
   898                              <2> 	;in:
   899                              <2> 		;eax selector
   900                              <2> 			;bit0:1 = 00
   901                              <2> 			;bit2 = ti, 0:GDT 1:LDT
   902                              <2> 			;bit3-15 = selector, 0 = any selector
   903                              <2> 		;edx Settings
   904                              <2> 				;Data        -D-L----1Pl10EWA
   905                              <2> 				;Code        -D-L----1Pl11CRA
   906                              <2> 				;LDT         ---A----1Pl00010
   907                              <2> 				;TSS         ---A----1Pl010B1
   908                              <2> 		;ecx = Size(in bytes) - Granulary bit is fixed automatically
   909                              <2> 		;		if ecx exceeds maximum limit without Granulary bit set(4kB steps)
   910                              <2> 		;		descriptor will automatically use Granulary bit
   911                              <2> 		;		and then the descriptor limit will be to the next 4kB boundary		
   912                              <2> 	;out:
   913                              <2> 		;cf clear,eax = selector
   914                              <2> 		;cf set  ,eax = error code		
   915                              <2> 			;ecx = Segment size
   916                              <2> 			;edx = Segment base
   917                              <2> 			;ebx = Descriptor base
   918                              <2> 
   919                              <2> 	
   920 0000027C 89C2                <2> 	mov	edx, eax
   921 0000027E 81E20000FF50        <2> 	and	edx, 50FF0000h
   922 00000284 81CA00008000        <2> 	or	edx, 00800000h		;Present bit
   923                              <2> 	;edx = settings
   924                              <2> 	
   925 0000028A E89D000000          <2> 	call	.create_desc	;(eax = selector, ebx = Desc Base) == (eax = selector)
   926 0000028F 7222                <2> 	jc	.create_error
   927 00000291 09D0                <2> 	or	eax, edx
   928                              <2> 	
   929 00000293 E8C0030000          <2> 	call	.alloc_mem	;(edx = Base, ecx = Size) == (ecx = Size(even 4kB) )
   930 00000298 720C                <2> 	jc	.create_error_desc
   931 0000029A E8BA020000          <2> 	call .write_desc	;(same) == (eax = [Settings][Selector], ebx = Desc Base, ecx = Size, edx = Base)
   932                              <2> 	
   933 0000029F 25FCFF0000          <2> 	and	eax, 0FFFCh
   934 000002A4 F8                  <2> 	clc
   935 000002A5 C3                  <2> 	ret
   936                              <2> 
   937                              <2> 	.create_error_desc:	
   938                              <2> 	;remove the allocated descriptor
   939 000002A6 C70300000000        <2> 	mov dword [ebx], 0
   940 000002AC C7430400000000      <2> 	mov dword [ebx+4], 0
   941                              <2> 	
   942                              <2> 	.create_error:
   943 000002B3 F9                  <2> 	stc
   944 000002B4 C3                  <2> 	ret
   945                              <2> 
   946                              <2> 
   947                              <2> ;===============================================================================	
   948                              <2> ;
   949                              <2> ;	call	desc.create_desc_ldt	;(eax = selector, ebx = Desc Base) == (ebx = [LDT][Selector])
   950                              <2> ;
   951                              <2> ;	Creates a new descriptor in specified LDT
   952                              <2> .create_desc_ldt:
   953 000002B5 51                  <2> 	push	ecx
   954 000002B6 89D8                <2> 		mov	eax, ebx
   955 000002B8 25FCFF0000          <2> 		and	eax, 0FFFCh	;eax = selector
   956                              <2> 		
   957 000002BD 52                  <2> 		push	edx
   958 000002BE 89DA                <2> 			mov	edx, ebx
   959 000002C0 C1EA10              <2> 			shr	edx, 10h
   960 000002C3 E84C020000          <2> 			call	desc.get_ldt	;(ebx = Base, ecx = limit) == (edx = selector)
   961 000002C8 5A                  <2> 		pop	edx
   962 000002C9 0F82C5000000        <2> 		jc near .create_desc_error
   963                              <2> 
   964 000002CF E969000000          <2> 	jmp	.spec
   965                              <2> 
   966                              <2> ;===============================================================================	
   967                              <2> ;
   968                              <2> ;	desc.get				;(eax [Settings][Selector]) == (edx Selector)
   969                              <2> ;
   970                              <2> ;	Change Data/Code descriptor settings
   971                              <2> ;
   972                              <2> 		;Data        0EWA
   973                              <2> 		;Code        1CRA
   974                              <2> .get:
   975 000002D4 0F02C2              <2> 	lar	eax, edx
   976 000002D7 7513                <2> 	jnz	.get_error
   977                              <2> 	
   978 000002D9 0FBAE00C            <2> 	bt	eax, 12	;Data/Code bit
   979 000002DD 730D                <2> 	jnc	.get_error
   980                              <2> 	
   981 000002DF 25000F0000          <2> 	and	eax, 00000F00h
   982 000002E4 C1E008              <2> 	shl	eax, 8	;
   983 000002E7 6689D0              <2> 	mov	ax, dx
   984 000002EA F8                  <2> 	clc
   985 000002EB C3                  <2> 	ret
   986                              <2> 	
   987                              <2> .get_error:
   988 000002EC F9                  <2> 	stc
   989 000002ED C3                  <2> 	ret
   990                              <2> 	
   991                              <2> ;===============================================================================	
   992                              <2> ;
   993                              <2> ;	desc.set				;() == (edx [Settings][Selector])
   994                              <2> ;
   995                              <2> ;	Change Data/Code descriptor settings
   996                              <2> ;
   997                              <2> .set:
   998 000002EE 50                  <2> 	push	eax
   999 000002EF 53                  <2> 	push	ebx
  1000                              <2> 		;Check descriptor
  1001 000002F0 0F02DA              <2> 		lar	ebx, edx		;Present, legal
  1002 000002F3 7533                <2> 		jnz	.set_error
  1003 000002F5 0FBAE30C            <2> 		bt	ebx, 12		;Data/Code segment
  1004 000002F9 732D                <2> 		jnc	.set_error
  1005 000002FB C1EB0D              <2> 		shr	ebx, 13		;Test privileges
  1006 000002FE 81E303000000        <2> 		and	ebx, 011b		;ebx = DPL
  1007 00000304 368B450C            <2> 		mov	eax, [caller_cs]
  1008 00000308 2503000000          <2> 		and	eax, 011b		;eax = CPL
  1009 0000030D 39D8                <2> 		cmp	eax, ebx
  1010 0000030F 7717                <2> 		ja	.set_error	;Error: not privileged
  1011                              <2> 		
  1012                              <2> 		;Get Descriptor Base
  1013 00000311 E81C020000          <2> 		call	desc.get_desc_base	;(ebx = Base) == (dx = selector)
  1014                              <2> 		
  1015                              <2> 		;Write settings
  1016 00000316 89D0                <2> 		mov	eax, edx
  1017 00000318 C1E810              <2> 		shr	eax, 10h
  1018 0000031B 240F                <2> 		and	al, 0Fh
  1019 0000031D 806305F0            <2> 		and byte [ebx + 5], 0F0h
  1020 00000321 084305              <2> 		or  byte [ebx + 5], al
  1021                              <2> 		
  1022                              <2> 		;Done
  1023 00000324 5B                  <2> 	pop	ebx
  1024 00000325 58                  <2> 	pop	eax
  1025 00000326 F8                  <2> 	clc
  1026 00000327 C3                  <2> 	ret
  1027                              <2> 	
  1028                              <2> .set_error
  1029 00000328 5B                  <2> 	pop	ebx
  1030 00000329 58                  <2> 	pop	eax
  1031 0000032A F9                  <2> 	stc
  1032 0000032B C3                  <2> 	ret
  1033                              <2> 
  1034                              <2> 
  1035                              <2> ;===============================================================================	
  1036                              <2> ;
  1037                              <2> ;desc.create_desc	;(eax = selector, ebx = Desc Base) == (eax = selector)
  1038                              <2> ;
  1039                              <2> .create_desc:
  1040                              <2> 	;creates a new selector in specified table
  1041                              <2> 	;in:	eax = selector
  1042                              <2> 		;bit 0:1 = 00
  1043                              <2> 		;bit 2 = ti, 0:GDT 1:LDT
  1044                              <2> 		;bit 3:15 = selector, 0 = any selector
  1045                              <2> 	;return:
  1046                              <2> 		;eax = selector
  1047                              <2> 		;ebx = linear address to descriptor
  1048                              <2> 		
  1049 0000032C 51                  <2> 	push	ecx
  1050 0000032D 25FCFF0000          <2> 		and	eax, 0FFFCh
  1051                              <2> 		
  1052 00000332 52                  <2> 		push	edx
  1053 00000333 89C2                <2> 			mov	edx, eax
  1054 00000335 E8B0010000          <2> 			call	desc.get_table	;(ebx = Table Base, ecx = Table Limit) == (dx = Selector(TI bit) )
  1055 0000033A 5A                  <2> 		pop	edx
  1056 0000033B 7257                <2> 		jc	.create_desc_error
  1057                              <2> 
  1058                              <2> 	.spec:	;Called by desc.create_desc_ldt
  1059                              <2> 
  1060                              <2> 		;is selector specified?, else any selector
  1061 0000033D 66A9F8FF            <2> 		test ax, 0FFF8h
  1062 00000341 7424                <2> 		jz   .any			;null selector = any selector
  1063                              <2> 
  1064                              <2> 		;ax = selector
  1065                              <2> 		;ecx = table limit
  1066                              <2> 		;ebx = table base
  1067                              <2> 			
  1068                              <2> 		;check if selector is free
  1069 00000343 50                  <2> 		push eax				;save selector
  1070                              <2> 
  1071                              <2> 			;check table bounds
  1072 00000344 0D07000000          <2> 			or   eax, 111b ; set bits 0-2 (upper bound of descriptor)
  1073 00000349 39C8                <2> 			cmp  eax, ecx
  1074 0000034B 7711                <2> 			ja   .out_of_bounds
  1075                              <2> 			;selector within bounds
  1076                              <2> 
  1077                              <2> 			;set ebx to point at descriptor
  1078 0000034D 25F8FF0000          <2> 			and  eax, 0FFF8h ;only keep selector index
  1079 00000352 01C3                <2> 			add  ebx, eax
  1080                              <2> 
  1081 00000354 58                  <2> 		pop  eax
  1082                              <2> 
  1083 00000355 0FBA6B040F          <2> 		bts dword [ebx	+ 4], 15	;Present bit
  1084 0000035A 7233                <2> 		jc   .create_desc_error_full			;Descriptor already present/taken
  1085                              <2> 	
  1086 0000035C 59                  <2> 	pop	ecx
  1087 0000035D C3                  <2> 	ret
  1088                              <2> 
  1089                              <2> 	.out_of_bounds:
  1090 0000035E 58                  <2> 		pop  eax ;restore stack
  1091 0000035F 59                  <2> 	pop	ecx
  1092 00000360 B82E000000          <2> 	mov  eax, err_table_bounds
  1093 00000365 F9                  <2> 	stc
  1094 00000366 C3                  <2> 	ret
  1095                              <2> 
  1096                              <2> 
  1097                              <2> .any:
  1098                              <2> 	;set ecx to counter of descriptors
  1099 00000367 41                  <2> 	inc	ecx		;if ecx = ...xxx111b
  1100 00000368 C1E903              <2> 	shr  ecx, 3	;ecx = number of descriptors in the table
  1101                              <2> 	
  1102 0000036B 2504000000          <2> 	and  eax, 04h	;keep ti bit
  1103 00000370 29D8                <2> 	sub  eax, ebx	;step 1/2: make selector
  1104                              <2> 
  1105 00000372 81F901000000        <2> 	cmp  ecx, 1
  1106 00000378 7615                <2> 	jbe	.create_desc_error_full
  1107                              <2> 
  1108 0000037A 49                  <2> 	dec	ecx		;don't count null descriptor
  1109                              <2> 
  1110                              <2> 	.find_free
  1111 0000037B 81C308000000        <2> 		add  ebx, 8
  1112                              <2> 
  1113 00000381 0FBA6B040F          <2> 		bts dword [ebx+4], 15 ;Present bit
  1114 00000386 7302                <2> 		jnc	.create_eax_sel
  1115                              <2> 
  1116 00000388 E2F1                <2> 		loop .find_free
  1117                              <2> 
  1118                              <2> 		;error: GDT/LDT full
  1119                              <2> 
  1120                              <2> 	.create_eax_sel
  1121 0000038A 59                  <2> 		pop	ecx
  1122 0000038B 01D8                <2> 		add  eax, ebx  ;step 2/2: make selector, eax = the new selector
  1123 0000038D F8                  <2> 		clc
  1124 0000038E C3                  <2> 		ret
  1125                              <2> 	
  1126                              <2> 	.create_desc_error_full:
  1127 0000038F B82D000000          <2> 		mov  eax, err_table_full
  1128                              <2> 		
  1129                              <2> 	.create_desc_error:
  1130 00000394 59                  <2> 		pop	ecx
  1131 00000395 F9                  <2> 		stc
  1132 00000396 C3                  <2> 		ret
  1133                              <2> 		
  1134                              <2> 
  1135                              <2> ;===============================================================================
  1136                              <2> ;
  1137                              <2> ;	desc.delete		;(eax Status) == (edx Selector)
  1138                              <2> ;
  1139                              <2> ;	Delete a data/code descriptor
  1140                              <2> ;
  1141                              <2> .delete:	
  1142 00000397 53                  <2> 	push	ebx
  1143 00000398 51                  <2> 	push	ecx
  1144                              <2> 
  1145                              <2> 		;Check type
  1146 00000399 0F02C2              <2> 		lar	eax, edx
  1147 0000039C 7519                <2> 		jnz	.delete_error
  1148                              <2> 		
  1149 0000039E 0FBAE00C            <2> 		bt	eax, 12		;Data/Code
  1150 000003A2 7313                <2> 		jnc	.delete_error	;not a data/code segment
  1151                              <2> 		
  1152                              <2> 		;Dealloc Lineary memory(lin + page)
  1153 000003A4 E835020000          <2> 		call	desc.get_seg_base	;(ebx = Segment Base) == (dx = Selector)
  1154 000003A9 0F03CA              <2> 		lsl	ecx, edx
  1155 000003AC 41                  <2> 		inc	ecx
  1156 000003AD E88E000000          <2> 		call	desc.delete_lin	;(eax Status) == (ebx Base, ecx Size)
  1157                              <2> 
  1158 000003B2 E875000000          <2> 		call	desc.delete_desc
  1159                              <2> 		
  1160                              <2> 		.delete_error
  1161 000003B7 59                  <2> 	pop	ecx
  1162 000003B8 5B                  <2> 	pop	ebx
  1163 000003B9 F8                  <2> 	clc
  1164 000003BA C3                  <2> 	ret
  1165                              <2> 
  1166                              <2> ;===============================================================================
  1167                              <2> ;
  1168                              <2> ;	desc.delete_module		;() == (edx [Module][Selector])
  1169                              <2> ;
  1170                              <2> ;	Delete a data/code descriptor in specified module
  1171                              <2> ;	TI flag in Selector is ignored
  1172                              <2> ;
  1173                              <2> .delete_module:
  1174 000003BB 53                  <2> 	push	ebx
  1175 000003BC 51                  <2> 	push	ecx
  1176 000003BD 52                  <2> 	push	edx
  1177 000003BE C1EA10              <2> 		shr	edx, 10h
  1178 000003C1 E84E010000          <2> 		call	desc.get_ldt	;(ebx = Base, ecx = limit) == (edx = selector)
  1179 000003C6 5A                  <2> 	pop	edx
  1180 000003C7 52                  <2> 	push	edx
  1181 000003C8 81E2F8FF0000        <2> 		and	edx, 0FFF8h
  1182 000003CE 41                  <2> 		inc	ecx
  1183 000003CF 81E1F8FF0000        <2> 		and	ecx, 0FFF8h
  1184 000003D5 39CA                <2> 		cmp	edx, ecx
  1185 000003D7 774E                <2> 		ja	.delete_module_error
  1186                              <2> 		
  1187 000003D9 01D3                <2> 		add	ebx, edx	;[ebx] = descriptor
  1188                              <2> 		
  1189                              <2> 		;Test Descriptor
  1190 000003DB 8B4B04              <2> 		mov	ecx, [ebx+4]
  1191 000003DE 81E100901000        <2> 		and	ecx, 00109000h
  1192 000003E4 81F900900000        <2> 		cmp	ecx, 00009000h			;Avail(interface) not set
  1193 000003EA 753B                <2> 		jne	.delete_module_error	;Not a data/code segment
  1194                              <2> 		
  1195                              <2> 		;Read Limit
  1196 000003EC 8B4B04              <2> 		mov	ecx, [ebx+4]
  1197 000003EF 668B0B              <2> 		mov	cx, [ebx]
  1198 000003F2 41                  <2> 		inc	ecx			;ecx = size(without granular)
  1199 000003F3 C1E10C              <2> 		shl	ecx, 12
  1200 000003F6 0FBA630417          <2> 		bt dword [ebx+4], 17h	;Granulary bit
  1201 000003FB 7203                <2> 		jc	.delete_module_gran
  1202 000003FD C1E90C              <2> 		shr	ecx, 12
  1203                              <2> 		.delete_module_gran:
  1204                              <2> 		;ecx = size
  1205                              <2> 		
  1206                              <2> 		;Read Base
  1207 00000400 8A7307              <2> 		mov	dh, [ebx+7]
  1208 00000403 8A5304              <2> 		mov	dl, [ebx+4]
  1209 00000406 C1E210              <2> 		shl	edx, 10h
  1210 00000409 668B5302            <2> 		mov	dx, [ebx+2]
  1211                              <2> 		;edx = base
  1212                              <2> 		
  1213                              <2> 		;Dealloc memory
  1214 0000040D 87DA                <2> 		xchg	ebx, edx
  1215 0000040F E82C000000          <2> 		call	desc.delete_lin		;() == (ebx Base, ecx Size)
  1216 00000414 7211                <2> 		jc	.delete_module_error
  1217                              <2> 		
  1218                              <2> 		;Remove Descriptor
  1219 00000416 C70300000000        <2> 		mov	[ebx], dword 0
  1220 0000041C C7430400000000      <2> 		mov	[ebx+4], dword 0
  1221                              <2> 		
  1222 00000423 5A                  <2> 	pop	edx
  1223 00000424 59                  <2> 	pop	ecx
  1224 00000425 5B                  <2> 	pop	ebx
  1225 00000426 C3                  <2> 	ret
  1226                              <2> 	
  1227                              <2> 		.delete_module_error:
  1228 00000427 F9                  <2> 		stc
  1229 00000428 5A                  <2> 	pop	edx	
  1230 00000429 59                  <2> 	pop	ecx
  1231 0000042A 5B                  <2> 	pop	ebx
  1232 0000042B C3                  <2> 	ret
  1233                              <2> ;===============================================================================
  1234                              <2> ;
  1235                              <2> ;	desc.delete_desc		;() == (edx Selector)
  1236                              <2> ;
  1237                              <2> ;	Delete the descriptor only, no checks are made
  1238                              <2> ;
  1239                              <2> .delete_desc:
  1240                              <2> 	;Delete descriptor
  1241 0000042C 53                  <2> 	push	ebx
  1242 0000042D E800010000          <2> 		call	desc.get_desc_base	;(ebx = Base) == (dx = selector)
  1243                              <2> 		
  1244                              <2> 		;Erase, write zeros
  1245 00000432 C70300000000        <2> 		mov dword [ebx], 0
  1246 00000438 C7430400000000      <2> 		mov dword [ebx + 4], 0
  1247 0000043F 5B                  <2> 	pop	ebx
  1248                              <2> 
  1249                              <2> ;===============================================================================
  1250                              <2> ;
  1251                              <2> ;	desc.delete_lin		;() == (ebx Base, ecx Size)
  1252                              <2> ;
  1253                              <2> ;	Delete a linear memory area
  1254                              <2> ;
  1255                              <2> .delete_lin:
  1256 00000440 52                  <2> 	push	edx
  1257 00000441 89DA                <2> 		mov	edx, ebx
  1258 00000443 E8DD030000          <2> 		call	page.dealloc_lin	;() == (edx = Base, ecx = Size)
  1259 00000448 7209                <2> 		jc	.delete_lin_error
  1260                              <2> 		
  1261 0000044A E85A020000          <2> 		call	desc.free_mem	;() == (ebx = lineary address, ecx = size)
  1262 0000044F 7202                <2> 		jc	.delete_lin_error
  1263 00000451 5A                  <2> 	pop	edx
  1264 00000452 C3                  <2> 	ret
  1265                              <2> 				
  1266                              <2> 	.delete_lin_error:
  1267 00000453 5A                  <2> 	pop	edx
  1268 00000454 C3                  <2> 	ret
  1269                              <2> ;===============================================================================
  1270                              <2> ;
  1271                              <2> ;desc.get_paddress:	(eax physical address) == (edx Selector, ebx Base, ecx Size)
  1272                              <2> 	;Return the Physical address and check descriptor size
  1273                              <2> 	
  1274                              <2> .get_paddress:
  1275 00000455 53                  <2> 	push	ebx
  1276 00000456 52                  <2> 	push	edx
  1277                              <2> 	
  1278 00000457 E811000000          <2> 		call	desc.get_linear_base	;(edx = Linear Base) == (dx = Selector, ebx = Base, ecx = Size)
  1279 0000045C 720C                <2> 		jc	.get_paddress_error
  1280 0000045E E8F9040000          <2> 		call	page.getpaddress	;(ebx = physical address) == (edx = linear address)
  1281 00000463 7205                <2> 		jc	.get_paddress_error
  1282                              <2> 		
  1283 00000465 89D8                <2> 		mov	eax, ebx
  1284                              <2> 	
  1285 00000467 5A                  <2> 	pop	edx
  1286 00000468 5B                  <2> 	pop	ebx
  1287 00000469 C3                  <2> 	ret
  1288                              <2> 	
  1289                              <2> 	.get_paddress_error:
  1290 0000046A 5A                  <2> 	pop	edx
  1291 0000046B 5B                  <2> 	pop	ebx
  1292 0000046C C3                  <2> 	ret
  1293                              <2> ;===============================================================================
  1294                              <2> 
  1295                              <2> ;desc.get_linear_base	;(eax = Linear Base) == (edx = Selector, ebx = Base, ecx = Size)
  1296                              <2>  	    
  1297                              <2> .get_linear_base:
  1298                              <2> 	;Get linear base from Selector
  1299                              <2> 	;where to allocate/deallocate memory
  1300                              <2> 	;also check limits
  1301                              <2> 
  1302                              <2> 	;in:
  1303                              <2> 	;    dx = Selector
  1304                              <2> 	;   ebx = Base
  1305                              <2> 	;   ecx = Size
  1306                              <2> 	;out:
  1307                              <2> 	;	edx = linear base
  1308                              <2> 	;	cf set if segment is too small
  1309                              <2> 
  1310 0000046D 52                  <2> 	push	edx
  1311 0000046E 51                  <2> 	push	ecx
  1312 0000046F 53                  <2> 	push	ebx
  1313                              <2> 			
  1314 00000470 E875000000          <2> 		call	desc.get_table	;(ebx = Table Base, ecx = Table Limit, eax = changed) == (dx = Selector(TI bit) )
  1315 00000475 7256                <2> 		jc	.limit_not_ok			;Table error: LDT does not exist
  1316                              <2> 		
  1317 00000477 89D0                <2> 		mov	eax, edx
  1318 00000479 25F8FF0000          <2> 		and	eax, 0000FFF8h			;Mask off TI and RPL bits
  1319 0000047E 01C3                <2> 		add	ebx, eax				;ebx = Linear address to Descriptor
  1320                              <2> 			
  1321                              <2> 		;Check present bit
  1322 00000480 8B4304              <2> 		mov	eax, [ebx + 4]
  1323 00000483 0FBAE00F            <2> 		bt	eax, 15
  1324 00000487 730C                <2> 		jnc	.get_linear_base_error
  1325                              <2> 		
  1326                              <2> 		;Check if it is data or code
  1327 00000489 0FBAE00C            <2> 		bt	eax, 12
  1328 0000048D 7210                <2> 		jc	.linear_is_data
  1329                              <2> 		
  1330                              <2> 		;Check if it is LDT or TSS
  1331 0000048F 0FBAE00A            <2> 		bt	eax, 10
  1332 00000493 730A                <2> 		jnc	.linear_is_data
  1333                              <2> 		
  1334                              <2> 	;Error: Descriptor is not of a type allowed
  1335                              <2> 		.get_linear_base_error:			
  1336 00000495 5B                  <2> 	pop	ebx
  1337 00000496 59                  <2> 	pop	ecx
  1338 00000497 5A                  <2> 	pop	edx
  1339 00000498 B83E000000          <2> 	mov	eax, err_page_descriptor
  1340 0000049D F9                  <2> 	stc
  1341 0000049E C3                  <2> 	ret
  1342                              <2> 			
  1343                              <2> 		.linear_is_data:
  1344                              <2> 
  1345                              <2> 		;get descriptor limit
  1346 0000049F 668B4306            <2> 		mov	ax, [ebx + 6]
  1347 000004A3 C1E010              <2> 		shl	eax, 10h
  1348 000004A6 668B03              <2> 		mov	ax, [ebx]
  1349                              <2> 		
  1350                              <2> 		;test granulary bit
  1351 000004A9 C1C00C              <2> 		rol  eax, 12			;removes unwanted bits
  1352 000004AC 0FBAE004            <2> 		bt	eax,	4
  1353 000004B0 7205                <2> 		jc	.gran_bit
  1354                              <2> 		
  1355 000004B2 C1E80C              <2> 		shr  eax, 12			
  1356 000004B5 EB05                <2> 		jmp short .got_desc_limit
  1357                              <2> 		
  1358                              <2> 		.gran_bit:
  1359 000004B7 0DFF0F0000          <2> 		or	eax, 0FFFh
  1360                              <2> 		
  1361                              <2> 		.got_desc_limit:
  1362                              <2> 
  1363 000004BC 89DA                <2> 		mov	edx, ebx		;save ebx for the future
  1364                              <2> 
  1365                              <2> 		;edx = Linear address to segment
  1366                              <2> 		;eax = descriptor limit
  1367                              <2> 		;ecx = allocation size
  1368                              <2> 			
  1369 000004BE 5B                  <2> 	pop	ebx			;ebx = base inside descriptor
  1370 000004BF 59                  <2> 	pop	ecx			;ecx = allocation size
  1371 000004C0 51                  <2> 	push	ecx
  1372 000004C1 53                  <2> 	push	ebx
  1373                              <2> 	
  1374                              <2> 		;check descriptor size
  1375 000004C2 39C3                <2> 		cmp	ebx, eax
  1376 000004C4 7707                <2> 		ja	.limit_not_ok
  1377 000004C6 01CB                <2> 		add  ebx, ecx
  1378 000004C8 40                  <2> 		inc	eax			;eax = size
  1379 000004C9 39C3                <2>  		cmp	ebx, eax
  1380 000004CB 760A                <2> 		jbe	.limit_ok
  1381                              <2> 		
  1382                              <2> 		.limit_not_ok:
  1383                              <2> 	;error, page count is larger than descriptor limit
  1384 000004CD 5B                  <2> 	pop	ebx
  1385 000004CE 59                  <2> 	pop	ecx
  1386 000004CF 5A                  <2> 	pop	edx
  1387 000004D0 B83F000000          <2> 	mov	eax, err_page_limit
  1388 000004D5 F9                  <2> 	stc
  1389 000004D6 C3                  <2> 	ret
  1390                              <2> 		
  1391                              <2> 	.limit_ok:
  1392                              <2> 	
  1393                              <2> 					;edx = Linear address to Descriptor
  1394                              <2> 	
  1395                              <2> 	;get linear base from descriptor
  1396 000004D7 8B4202              <2> 	mov	eax, [edx + 2]
  1397 000004DA C1E008              <2> 	shl	eax, 8
  1398 000004DD 8A4207              <2> 	mov	al, [edx + 7]
  1399 000004E0 C1C808              <2> 	ror	eax, 8
  1400                              <2> 					;eax = linear base from descriptor
  1401                              <2> 	
  1402 000004E3 5B                  <2> 	pop	ebx			;ebx = base in descriptor
  1403 000004E4 59                  <2> 	pop	ecx
  1404 000004E5 5A                  <2> 	pop	edx
  1405                              <2> 	
  1406 000004E6 01D8                <2> 	add	eax, ebx		;eax = linear base for page to work at
  1407 000004E8 F8                  <2> 	clc
  1408 000004E9 C3                  <2> 	ret
  1409                              <2> 
  1410                              <2> ;===============================================================================
  1411                              <2> 
  1412                              <2> ;desc.get_table	;(ebx = Table Base, ecx = Table Limit) == (dx = Selector(TI bit) )
  1413                              <2> 
  1414                              <2> .get_table:
  1415                              <2> 	;get Table base + limits
  1416                              <2> 	;in:	dx = selector(uses only TI bit)
  1417                              <2> 	;out:
  1418                              <2> 	
  1419                              <2> 	;get which table
  1420 000004EA 660FBAE202          <2> 	bt	dx, 2	 ;check TI bit
  1421 000004EF 730C                <2> 	jnc   .get_gdt
  1422                              <2> 	
  1423                              <2> 	;Get LDT
  1424 000004F1 52                  <2> 		push	edx
  1425 000004F2 0F00C2              <2> 			sldt	dx
  1426 000004F5 E81A000000          <2> 			call	desc.get_ldt	;(ebx = Base, ecx = limit) == (edx = selector)
  1427 000004FA 5A                  <2> 		pop	edx
  1428 000004FB F8                  <2> 		clc
  1429 000004FC C3                  <2> 		ret
  1430                              <2> 		
  1431                              <2> 	.get_gdt:
  1432                              <2> 		;get GDT base+length
  1433 000004FD 83EC08              <2> 		sub	esp, byte 8		;Make room for Base and limit to be written into d_table
  1434                              <2> 
  1435 00000500 360F010424          <2> 			sgdt [d_table]
  1436                              <2> 	
  1437 00000505 360FB70C24          <2> 			movzx ecx, word [d_table_lim]		;ecx = table limit
  1438 0000050A 368B5C2402          <2> 			mov	 ebx, [d_table_base]		;ebx = table base
  1439                              <2> 	
  1440 0000050F 83C408              <2> 		add	esp, byte 8			;return stack space
  1441                              <2> 
  1442 00000512 F8                  <2> 		clc
  1443 00000513 C3                  <2> 		ret
  1444                              <2> 		
  1445                              <2> 		
  1446                              <2> ;===============================================================================
  1447                              <2> ;
  1448                              <2> ;	desc.get_ldt	;(ebx = Base, ecx = limit) == (edx = selector)
  1449                              <2> .get_ldt:
  1450 00000514 81E2FFFF0000        <2> 	and	edx, 0000FFFFh
  1451                              <2> 	;get LDT selector
  1452 0000051A 83EC04              <2> 	sub	esp, byte 4			;make room for selector
  1453                              <2> 		
  1454 0000051D 0F03CA              <2> 		lsl	ecx, edx		;Make sure it is a legal Segment
  1455 00000520 750B                <2> 		jnz	.ldt_error
  1456                              <2> 		
  1457 00000522 E877000000          <2> 		call desc.get_ldt_base	;(ebx = Base) == (dx = Selector)
  1458 00000527 7204                <2> 		jc	.ldt_error			;Error: Selector does not point at a LDT descriptor
  1459                              <2> 		
  1460 00000529 83C404              <2> 	add	esp, byte 4		;return stack space
  1461 0000052C C3                  <2> 	ret
  1462                              <2> 	
  1463                              <2> 		.ldt_error:
  1464 0000052D 83C404              <2> 	add	esp, byte 4		;return stack space
  1465                              <2> 	
  1466                              <2> 	;mov	eax, err_desc_LDT does not exist
  1467 00000530 F9                  <2> 	stc
  1468 00000531 C3                  <2> 	ret
  1469                              <2> 
  1470                              <2> 		
  1471                              <2> ;===============================================================================
  1472                              <2> ;
  1473                              <2> ;desc.get_desc_base	;(ebx = Base) == (dx = selector)
  1474                              <2> 
  1475                              <2> .get_desc_base:
  1476 00000532 52                  <2> 	push	edx
  1477 00000533 51                  <2> 	push	ecx
  1478                              <2> 		;Get Table Base
  1479 00000534 E8B1FFFFFF          <2> 		call	desc.get_table	;(ebx = Table Base, ecx = Table Limit) == (dx = Selector(TI bit) )
  1480                              <2> 		
  1481 00000539 81E2F8FF0000        <2> 		and	edx, 0000FFF8h
  1482 0000053F 81CA07000000        <2> 		or	edx, 0111b
  1483 00000545 39CA                <2> 		cmp	edx, ecx
  1484 00000547 770C                <2> 		ja	.get_desc_base_error
  1485 00000549 81E2F8FF0000        <2> 		and	edx, 0FFF8h
  1486                              <2> 		
  1487 0000054F 01D3                <2> 		add	ebx, edx
  1488 00000551 59                  <2> 	pop	ecx
  1489 00000552 5A                  <2> 	pop	edx	
  1490 00000553 F8                  <2> 	clc		
  1491 00000554 C3                  <2> 	ret
  1492                              <2> 	
  1493                              <2> 	.get_desc_base_error:
  1494 00000555 59                  <2> 	pop	ecx
  1495 00000556 5A                  <2> 	pop	edx	
  1496 00000557 F9                  <2> 	stc
  1497 00000558 C3                  <2> 	ret
  1498                              <2> 				
  1499                              <2> ;===============================================================================
  1500                              <2> ;
  1501                              <2> ;desc.write_desc	;(same) == (eax = [Settings][Selector], ebx = Desc Base, ecx = Size, edx = Base)
  1502                              <2> 
  1503                              <2> 
  1504                              <2> .write_desc:	
  1505                              <2> 	;Write data to selector
  1506                              <2> 	;ebx = linear pointer to descriptor in the table
  1507                              <2> 	;eax = 16:31	Settings
  1508                              <2> 		;Data        -D-L----1Pl10EWA
  1509                              <2> 		;Code        -D-L----1Pl11CRA
  1510                              <2> 		;LDT         ---A----1Pl00010
  1511                              <2> 		;TSS         ---A----1Pl010B1
  1512                              <2> 	;	0:15		Selector(including TI bit) - to be returned
  1513                              <2> 	;ecx = size
  1514                              <2> 	;edx = base
  1515 00000559 51                  <2> 	push	ecx
  1516 0000055A 9C                  <2> 	pushfd
  1517 0000055B FA                  <2> 	cli
  1518                              <2> 	
  1519                              <2> 	;write all data into descriptor
  1520 0000055C 895304              <2> 	mov	[ebx + 4], edx
  1521 0000055F 895302              <2> 	mov	[ebx + 2], edx		;Base done
  1522                              <2> 	
  1523 00000562 81E901000000        <2> 	sub	ecx, 1			;ecx = limit = size - 1
  1524 00000568 7230                <2> 	jc	.write_desc_error	;if size is zero
  1525                              <2> 		
  1526                              <2> 	;check limit size, use granulary bit?
  1527 0000056A F7C10000F0FF        <2> 	test	ecx, 0FFF00000h
  1528 00000570 7407                <2> 	jz	.write_limit
  1529                              <2> 	
  1530 00000572 C1E90C              <2> 	shr	ecx, 12			;return size in 4kB chunks
  1531 00000575 0FBAE81F            <2> 	bts	eax, 31			;set Granulary bit
  1532                              <2> 	
  1533                              <2> 	.write_limit:
  1534 00000579 66890B              <2> 	mov	[ebx]    , cx		;Limit 0:15
  1535 0000057C C1E910              <2> 	shr	ecx, 10h
  1536 0000057F 884B06              <2> 	mov	[ebx + 6], cl		;Limit16:19
  1537                              <2> 	
  1538 00000582 89C1                <2> 	mov	ecx, eax
  1539 00000584 C1E910              <2> 	shr	ecx, 10h
  1540 00000587 6681E1FFF0          <2> 	and	cx, 0F0FFh
  1541 0000058C 66816305000F        <2> 	and word [ebx + 5], 0F00h
  1542 00000592 66094B05            <2> 	or	[ebx + 5], cx		;Settings done
  1543                              <2> 	
  1544                              <2> 	;ax=selector
  1545 00000596 9D                  <2> 	popfd
  1546 00000597 59                  <2> 	pop	ecx
  1547 00000598 F8                  <2> 	clc
  1548 00000599 C3                  <2> 	ret
  1549                              <2> 
  1550                              <2> .write_desc_error:
  1551 0000059A 9D                  <2> 	popfd
  1552 0000059B 59                  <2> 	pop	ecx
  1553 0000059C F9                  <2> 	stc
  1554 0000059D C3                  <2> 	ret
  1555                              <2> 
  1556                              <2> ;===============================================================================
  1557                              <2> 
  1558                              <2> ;desc.get_ldt_base	;(ebx = Base) == (dx = Selector)
  1559                              <2> 
  1560                              <2> .get_ldt_base:
  1561                              <2> 	;Same as desc_get_base, except settings is destroyed
  1562                              <2> 	;Make sure the descriptor is a LDT
  1563                              <2> 		;LDT         ---A----1Pl00010
  1564 0000059E E84B000000          <2> 	call	desc.get_seg_base_type	;(ebx = Segment Base, edx = [Settings][Selector]) == (dx = Selector)
  1565 000005A3 7214                <2> 	jc	.get_ldt_base_error
  1566                              <2> 
  1567                              <2> 	;check type
  1568 000005A5 C1CA10              <2> 	ror	edx, 10h
  1569 000005A8 6681E29F00          <2> 	and	dx, 10011111b		;bits to check
  1570 000005AD 6681FA8200          <2> 	cmp	dx, 10000010b		;equal?
  1571 000005B2 7505                <2> 	jne	.get_ldt_base_error
  1572                              <2> 	
  1573 000005B4 C1EA10              <2> 	shr	edx, 10h
  1574 000005B7 F8                  <2> 	clc					;it is a LDT
  1575 000005B8 C3                  <2> 	ret
  1576                              <2> 	
  1577                              <2> 	.get_ldt_base_error:
  1578 000005B9 C1EA10              <2> 	shr	edx, 10h
  1579 000005BC F9                  <2> 	stc
  1580 000005BD C3                  <2> 	ret
  1581                              <2> 	
  1582                              <2> 	
  1583                              <2> ;===============================================================================
  1584                              <2> 
  1585                              <2> ;desc.get_tss_base	;(ebx = Base) == (dx = Selector)
  1586                              <2> 
  1587                              <2> .get_tss_base:
  1588                              <2> 	;Same as desc_get_base, except settings is destroyed
  1589                              <2> 	;Make sure the descriptor is a TSS
  1590                              <2> 		;Data        -D-L----1Pl10EWA
  1591                              <2> 		;Code        -D-L----1Pl11CRA
  1592                              <2> 		;LDT         ---A----1Pl00010
  1593                              <2> 		;TSS         ---A----1Pl0S0B1
  1594 000005BE E82B000000          <2> 	call	desc.get_seg_base_type	;(ebx = Segment Base, edx = [Settings][Selector]) == (dx = Selector)
  1595 000005C3 72F4                <2> 	jc	.get_ldt_base_error
  1596                              <2> 
  1597                              <2> 	;check type
  1598 000005C5 C1CA10              <2> 	ror	edx, 10h
  1599 000005C8 6681F21400          <2> 	xor	dx, 00010100b		;make zeros to ones, ones to zeros
  1600 000005CD 6681E29D00          <2> 	and	dx, 10011101b		;bits to check
  1601 000005D2 6681FA9D00          <2> 	cmp	dx, 10011101b		;equal?
  1602 000005D7 75E0                <2> 	jne	.get_ldt_base_error
  1603                              <2> 	
  1604 000005D9 C1EA10              <2> 	shr	edx, 10h
  1605 000005DC F8                  <2> 	clc					;it is a TSS
  1606 000005DD C3                  <2> 	ret
  1607                              <2> 
  1608                              <2> ;===============================================================================
  1609                              <2> ;
  1610                              <2> ;desc.get_seg_base	;(ebx = Segment Base) == (dx = Selector)
  1611                              <2> ;
  1612                              <2> .get_seg_base:
  1613                              <2> 
  1614 000005DE 50                  <2> 	push	eax
  1615 000005DF 51                  <2> 	push	ecx
  1616 000005E0 31DB                <2> 		xor	ebx, ebx
  1617 000005E2 31C9                <2> 		xor	ecx, ecx
  1618 000005E4 E884FEFFFF          <2> 		call	desc.get_linear_base	;(eax = Linear Base) == (edx = Selector, ebx = Base, ecx = Size)
  1619 000005E9 89C3                <2> 		mov	ebx, eax
  1620 000005EB 59                  <2> 	pop	ecx
  1621 000005EC 58                  <2> 	pop	eax
  1622 000005ED C3                  <2> 	ret
  1623                              <2> 	
  1624                              <2> ;===============================================================================
  1625                              <2> ;
  1626                              <2> ;desc.get_seg_base_type	;(ebx = Segment Base, edx = [Settings][Selector]) == (dx = Selector)
  1627                              <2> ;get descriptor base and type
  1628                              <2> 
  1629                              <2> .get_seg_base_type:
  1630                              <2> 	
  1631 000005EE 51                  <2> 	push	ecx
  1632 000005EF 52                  <2> 	push	edx
  1633                              <2> 	
  1634                              <2> 		;get table base
  1635 000005F0 660FBAE202          <2> 		bt	dx, 2	 ;check TI bit
  1636 000005F5 7316                <2> 		jnc   .get_base_gdt
  1637                              <2> 		;jmp  .get_base_ldt
  1638                              <2> 
  1639                              <2> 	;get LDT Base
  1640                              <2> 		.get_base_ldt:
  1641 000005F7 0F00C2              <2> 		sldt dx			;stores a selector to the LDT
  1642 000005FA E89FFFFFFF          <2> 		call desc.get_ldt_base	;(ebx = Base) == (dx = Selector)
  1643 000005FF 7208                <2> 		jc	.get_base_error_pop
  1644                              <2> 
  1645 00000601 0F03CA              <2> 		lsl	ecx, edx
  1646                              <2> 	
  1647 00000604 E914000000          <2> 		jmp	.get_base_spec
  1648                              <2> 
  1649                              <2> 		.get_base_error_pop:
  1650                              <2> 		
  1651                              <2> 	.get_base_error:
  1652 00000609 5A                  <2> 	pop	edx
  1653 0000060A 59                  <2> 	pop	ecx
  1654 0000060B F9                  <2> 	stc
  1655 0000060C C3                  <2> 	ret
  1656                              <2> 			
  1657                              <2> 		.get_base_gdt:
  1658                              <2> 		;get GDT base
  1659 0000060D 83EC08              <2> 		sub	esp, byte 8		;Make room for Base and limit to be written into d_table
  1660 00000610 360F010424          <2> 			sgdt [d_table]
  1661 00000615 368B5C2402          <2> 			mov	 ebx, [d_table_base]		;ebx = table base
  1662 0000061A 83C408              <2> 		add	esp, byte 8			;return stack space
  1663                              <2> 
  1664                              <2> 		.get_base_spec:	
  1665                              <2> 
  1666                              <2> 		;Check Descriptor
  1667 0000061D 0F02CA              <2> 		lar	ecx, edx
  1668 00000620 75E7                <2> 		jnz	.get_base_error	;Descriptor problem: not present, illegal type, out of table limits...
  1669                              <2> 		
  1670 00000622 0FBAE10F            <2> 		bt	ecx, 15
  1671 00000626 73E1                <2> 		jnc	.get_base_error	;Descriptor not present
  1672                              <2> 		
  1673                              <2> 		;Check if it is data or code
  1674 00000628 0FBAE10C            <2> 		bt	ecx, 12			;Bit is 1 for Data and Code
  1675 0000062C 7206                <2> 		jc	.is_data
  1676                              <2> 		
  1677                              <2> 		;Check if it is LDT or TSS
  1678 0000062E 0FBAE10A            <2> 		bt	ecx, 10			;Bit is 0 for LDT and TSS
  1679 00000632 72D5                <2> 		jc	.get_base_error
  1680                              <2> 		
  1681                              <2> 		.is_data:
  1682                              <2> 
  1683                              <2> 		;set ebx to point at descriptor
  1684 00000634 81E2F8FF0000        <2> 		and  edx, 0FFF8h 		;only keep selector index
  1685 0000063A 01D3                <2> 		add  ebx, edx			;ebx = Pointer at Descriptor
  1686                              <2> 		
  1687                              <2> 		;get descriptor base into ebx
  1688 0000063C 89D9                <2> 		mov	ecx, ebx
  1689 0000063E 8B5902              <2> 		mov	ebx, [ecx + 2]
  1690 00000641 C1C308              <2> 		rol	ebx, 8
  1691 00000644 8A5907              <2> 		mov	bl, [ecx + 7]
  1692 00000647 C1CB08              <2> 		ror	ebx, 8
  1693                              <2> 		;ebx = descriptor base
  1694                              <2> 	
  1695 0000064A 5A                  <2> 	pop	edx
  1696                              <2> 		
  1697 0000064B C1CA10              <2> 	ror	edx, 10h
  1698 0000064E 668B5105            <2> 	mov	dx, [ecx + 5]
  1699 00000652 C1C210              <2> 	rol	edx, 10h			;edx = [Settings][Selector]
  1700                              <2> 		
  1701 00000655 59                  <2> 	pop	ecx
  1702                              <2> 
  1703 00000656 F8                  <2> 	clc
  1704 00000657 C3                  <2> 	ret
  1705                              <2> 		
  1706                              <2> 		
  1707                              <2> ;==============================================
  1708                              <2> ;==============================================
  1709                              <2> ;=========					============
  1710                              <2> ;=========	Memory Management	============
  1711                              <2> ;=========					============
  1712                              <2> ;==============================================
  1713                              <2> ;==============================================
  1714                              <2> 		
  1715                              <2> 		
  1716                              <2> 		
  1717                              <2> 		
  1718                              <2> 		
  1719                              <2> 		
  1720                              <2> 		
  1721                              <2> 		
  1722                              <2> ;===============================================================================
  1723                              <2> 
  1724                              <2> ;desc.alloc_mem	;(edx = Base) == (ecx = Size)
  1725                              <2> 
  1726                              <2> .alloc_mem:
  1727                              <2> 	;get linear memory from Free Linear Memory list
  1728                              <2> 	;in:  ecx = size in bytes
  1729                              <2> 	;out: edx = linear pointer
  1730                              <2> 	;memory is reserved in 4kB chunks
  1731 00000658 50                  <2> 	push	eax
  1732 00000659 53                  <2> 	push	ebx
  1733 0000065A 51                  <2> 	push	ecx
  1734                              <2> 	
  1735 0000065B 81C1FF0F0000        <2> 	add	ecx,      0FFFh
  1736 00000661 81E100F0FFFF        <2> 	and	ecx, 0FFFFF000h	;4kB boundary
  1737                              <2> 	
  1738 00000667 BB00304100          <2> 	mov	ebx, lin_FLM * pages
  1739                              <2> 	
  1740                              <2> 	.check_size:
  1741                              <2> 		;Check size of FLM Entry
  1742 0000066C 8B4304              <2> 		mov	eax, [ebx + 4]
  1743 0000066F 2B03                <2> 		sub	eax, [ebx]		;eax = size of free memory
  1744 00000671 740E                <2> 		jz	.err_out_of_memory
  1745 00000673 39C8                <2> 		cmp	eax, ecx
  1746 00000675 770F                <2> 		ja	.get_lin			;entry is larger than wanted memory
  1747 00000677 7416                <2> 		je	.get_lin_entry		;entry size = requested size
  1748                              <2> 		
  1749                              <2> 		;go to the next entry
  1750 00000679 81C308000000        <2> 		add	ebx, 8
  1751                              <2> 		
  1752 0000067F EBEB                <2> 		jmp .check_size
  1753                              <2> 
  1754                              <2> 		.err_out_of_memory:
  1755                              <2> 			;Error: not enough memory:
  1756                              <2> 			;	1: out of lineary memory
  1757                              <2> 			;	2: no entry with the specified size(lineary memory is too fragmented)
  1758 00000681 59                  <2> 			pop	ecx
  1759 00000682 5B                  <2> 			pop	ebx
  1760 00000683 58                  <2> 			pop	eax
  1761 00000684 F9                  <2> 			stc
  1762 00000685 C3                  <2> 			ret
  1763                              <2> 			
  1764                              <2> 	.get_lin:
  1765                              <2> 	;current FLM entry is big enough
  1766                              <2> 	
  1767 00000686 8B13                <2> 	mov	edx, [ebx]	;edx = linear base for memory taken from the FLM table
  1768 00000688 010B                <2> 	add	[ebx], ecx
  1769 0000068A E915000000          <2> 	jmp near .done
  1770                              <2> 	
  1771                              <2> 	.get_lin_entry:
  1772                              <2> 	;requested size = current entry size
  1773                              <2> 
  1774 0000068F 8B13                <2> 	mov	edx, [ebx]	;edx = linear base for memory taken from the FLM table
  1775                              <2> 
  1776                              <2> 	;current entry is empty, move all following entries one step back over current entry
  1777                              <2> 	
  1778                              <2> 	.move_FLM:
  1779                              <2> 		;move the next entry one step back
  1780 00000691 8B4308              <2> 		mov 	eax, [ebx + 8]
  1781 00000694 8903                <2> 		mov	[ebx], eax
  1782 00000696 8B430C              <2> 		mov	eax, [ebx + 12]
  1783 00000699 894304              <2> 		mov	[ebx + 4], eax
  1784                              <2> 		
  1785 0000069C 83C308              <2> 		add	ebx, byte 8
  1786                              <2> 		
  1787 0000069F 833B00              <2> 		cmp dword [ebx], byte 0
  1788 000006A2 75ED                <2> 		jne	.move_FLM
  1789                              <2> 	
  1790                              <2> 	.done:
  1791                              <2> 	
  1792 000006A4 59                  <2> 	pop	ecx
  1793 000006A5 5B                  <2> 	pop	ebx
  1794 000006A6 58                  <2> 	pop	eax
  1795 000006A7 F8                  <2> 	clc
  1796 000006A8 C3                  <2> 	ret
  1797                              <2> 
  1798                              <2> 	
  1799                              <2> ;===============================================================================
  1800                              <2> 
  1801                              <2> ;desc.free_mem	;() == (ebx = lineary address, ecx = size)
  1802                              <2> 
  1803                              <2> .free_mem:
  1804                              <2> 	;return linear memory to FLM
  1805                              <2> 	;in:  ebx = linear pointer
  1806                              <2> 	;     ecx = size in bytes
  1807                              <2> 	;memory is returned in 4kB chunks
  1808                              <2> 	
  1809 000006A9 53                  <2> 	push	ebx
  1810 000006AA 51                  <2> 	push	ecx
  1811 000006AB 52                  <2> 	push	edx
  1812                              <2> 	
  1813 000006AC 89DA                <2> 	mov	edx, ebx
  1814                              <2> 	
  1815 000006AE 01D1                <2> 	add	ecx, edx
  1816 000006B0 81C1FF0F0000        <2> 	add	ecx,      0FFFh
  1817 000006B6 81E100F0FFFF        <2> 	and	ecx, 0FFFFF000h	;4kB boundary
  1818 000006BC 81E200F0FFFF        <2> 	and	edx, 0FFFFF000h	;4kB boundary
  1819                              <2> 	
  1820                              <2> 	;linear memory to return
  1821                              <2> 	;edx = start
  1822                              <2> 	;ecx = end
  1823                              <2> 	
  1824 000006C2 BB00304100          <2> 	mov	ebx, lin_FLM * pages
  1825                              <2> 	
  1826                              <2> 	.find_area:
  1827 000006C7 3B0B                <2> 		cmp	ecx, [ebx]
  1828 000006C9 7417                <2> 		je	.add_to_entry_start
  1829 000006CB 721C                <2> 		jb	.insert_before_entry
  1830 000006CD 3B5304              <2> 		cmp	edx, [ebx + 4]
  1831 000006D0 7634                <2> 		jbe	.add_to_entry_end
  1832                              <2> 		
  1833                              <2> 		;check next
  1834 000006D2 81C308000000        <2> 		add	ebx, 8
  1835 000006D8 81FBF83F4100        <2> 		cmp	ebx, (lin_FLM + size_FLM) * pages - 8
  1836 000006DE 73FE                <2> 		jae	$					;FLM table is too small
  1837 000006E0 EBE5                <2> 		jmp	.find_area		
  1838                              <2> 		
  1839                              <2> 		
  1840                              <2> 	.add_to_entry_start:
  1841 000006E2 8913                <2> 		mov	[ebx], edx
  1842 000006E4 E94A000000          <2> 		jmp	.return_free_lin_done
  1843                              <2> 	
  1844                              <2> 	.insert_before_entry:
  1845                              <2> 
  1846                              <2> 		;move all entries one step forward
  1847 000006E9 8713                <2> 		xchg	edx, [ebx]
  1848 000006EB 874B04              <2> 		xchg ecx, [ebx + 4]
  1849                              <2> 		
  1850 000006EE 81F900000000        <2> 		cmp	ecx, 0
  1851 000006F4 743D                <2> 		je	.return_free_lin_done
  1852                              <2> 		
  1853 000006F6 81C308000000        <2> 		add	ebx, 8
  1854 000006FC 81FBF83F4100        <2> 		cmp	ebx, (lin_FLM + size_FLM) * pages - 8
  1855 00000702 73FE                <2> 		jae	$					;FLM table is too small
  1856                              <2> 		
  1857 00000704 EBE3                <2> 		jmp	.insert_before_entry
  1858                              <2> 			
  1859                              <2> 	.add_to_entry_end:
  1860 00000706 394B08              <2> 		cmp	[ebx + 8], ecx
  1861 00000709 7525                <2> 		jne	.add_to_end
  1862 0000070B 8B4B08              <2> 		mov	ecx, [ebx + 8]
  1863                              <2> 		
  1864                              <2> 		.move_back:
  1865                              <2> 		;move remaining entries one step back
  1866 0000070E 8B5308              <2> 			mov	edx, [ebx +  8]
  1867 00000711 8B4B0C              <2> 			mov	ecx, [ebx + 0Ch]
  1868 00000714 8913                <2> 			mov	[ebx], edx
  1869 00000716 890B                <2> 			mov	[ebx], ecx
  1870                              <2> 			
  1871 00000718 81F900000000        <2> 			cmp	ecx, 0
  1872 0000071E 7413                <2> 			je	.return_free_lin_done
  1873                              <2> 			
  1874 00000720 81C308000000        <2> 			add	ebx, 8
  1875 00000726 81FBF83F4100        <2> 			cmp	ebx, (lin_FLM + size_FLM) * pages - 8
  1876 0000072C 73FE                <2> 			jae	$					;FLM table is too small - this should never occur here
  1877                              <2> 			
  1878 0000072E EBDE                <2> 			jmp	.move_back
  1879                              <2> 		
  1880                              <2> 		.add_to_end
  1881 00000730 894B04              <2> 		mov	[ebx + 4], ecx
  1882                              <2> ;		jmp	.return_done
  1883                              <2> 			
  1884                              <2> 	.return_free_lin_done:
  1885 00000733 5A                  <2> 	pop	edx
  1886 00000734 59                  <2> 	pop	ecx
  1887 00000735 5B                  <2> 	pop	ebx
  1888 00000736 F8                  <2> 	clc
  1889 00000737 C3                  <2> 	ret
  1890                              <2> 	
  1891                              <1> %include 'page.asm'
  1892                              <2> 
  1893                              <2> ;Page management
  1894                              <2> page:
  1895                              <2> 
  1896                              <2> ;===============================================================================
  1897                              <2> ;
  1898                              <2> ;page.freemem		;(eax Free memory) == ()
  1899                              <2> ;	Get free physical memory
  1900                              <2> ;
  1901                              <2> .freemem:
  1902 00000738 53                  <2> 	push	ebx
  1903 00000739 8B1D04004000        <2> 		mov	ebx, [System.lin_FPT]
  1904 0000073F 8B03                <2> 		mov	eax, [ebx]		;get address to last page
  1905 00000741 C1E00A              <2> 		shl	eax, 12 - 2		;12: size of page, 4: size of page entry
  1906 00000744 5B                  <2> 	pop	ebx
  1907 00000745 F8                  <2> 	clc
  1908 00000746 C3                  <2> 	ret
  1909                              <2> 	
  1910                              <2> 
  1911                              <2> ;===============================================================================
  1912                              <2> ;
  1913                              <2> ;page.alloc	;() == (edx = [Settings][Selector], ebx = Base, ecx = Size)
  1914                              <2> 
  1915                              <2> .alloc:
  1916                              <2> 	;allocates one or more pages to a memory area specified by a descriptor
  1917                              <2> 	;in:
  1918                              <2> 	;   eax = 0:15 Selector
  1919                              <2> 	;		16	-
  1920                              <2> 	;		17	Writeable
  1921                              <2> 	;		18	User
  1922                              <2> 	;		19	PWT - Page Write-through
  1923                              <2> 	;		20	PCD - Page Cache Disabled
  1924                              <2> 	;   ebx = Base
  1925                              <2> 	;   ecx = size
  1926                              <2> 
  1927 00000747 50                  <2> 	push	eax
  1928 00000748 51                  <2> 	push	ecx
  1929 00000749 52                  <2> 	push	edx
  1930                              <2> 
  1931 0000074A 81F900000000        <2> 		cmp	ecx, 0
  1932 00000750 7425                <2> 		je	.alloc_done
  1933                              <2> 
  1934 00000752 E816FDFFFF          <2> 		call	desc.get_linear_base	;(eax = Linear Base) == (edx = Selector, ebx = Base, ecx = Size)
  1935 00000757 721F                <2> 		jc	.alloc_error
  1936                              <2> 			
  1937 00000759 81C1FF0F0000        <2> 	 	add	ecx, 0FFFh
  1938 0000075F C1E90C              <2> 		shr	ecx, 12			;ecx = number of pages
  1939                              <2> 		
  1940 00000762 92                  <2> 		xchg	eax, edx
  1941                              <2> 		
  1942 00000763 C1E810              <2> 		shr	eax, 10h
  1943 00000766 251E000000          <2> 		and	eax, 011110b
  1944 0000076B 0D01000000          <2> 		or	eax, 000001b		;Present bit
  1945                              <2> 
  1946                              <2> 		;.burst:
  1947 00000770 E807000000          <2> 		call	page.popfree_burst		;() == ;(eax = Settings, edx = Linear Address, ecx = pages)
  1948 00000775 7201                <2> 		jc	.alloc_error
  1949                              <2> 	
  1950                              <2> 		.alloc_done:
  1951 00000777 F8                  <2> 		clc
  1952                              <2> 	.alloc_error:
  1953 00000778 5A                  <2> 	pop	edx
  1954 00000779 59                  <2> 	pop	ecx
  1955 0000077A 58                  <2> 	pop	eax
  1956 0000077B C3                  <2> 	ret
  1957                              <2> 
  1958                              <2> ;===============================================================================
  1959                              <2> 
  1960                              <2> ;page.popfree_burst		;() == ;(eax = Settings, edx = Linear Address, ecx = pages)
  1961                              <2> 
  1962                              <2> 	;Allocate ecx pages starting at ebx
  1963                              <2> 
  1964                              <2> .popfree_burst:	;allocate free pages
  1965 0000077C 51                  <2> 	push	ecx
  1966 0000077D 06                  <2> 	push	es
  1967 0000077E 57                  <2> 	push	edi
  1968 0000077F 56                  <2> 	push	esi
  1969 00000780 9C                  <2> 	pushf
  1970 00000781 52                  <2> 	push	edx
  1971 00000782 50                  <2> 	push	eax
  1972 00000783 FA                  <2> 	cli
  1973                              <2> 
  1974                              <2> 		;Make sure all PT are allocated
  1975 00000784 C1E10C              <2> 		shl	ecx, 12
  1976 00000787 E840010000          <2> 		call	.allocate_PT	;() == (edx = linear address, ecx = size)
  1977 0000078C C1E90C              <2> 		shr	ecx, 12
  1978                              <2> 		
  1979                              <2> 		;Check free memory
  1980 0000078F 8B3504004000        <2> 		mov	esi, [System.lin_FPT]
  1981 00000795 8B06                <2> 		mov	eax, [esi]
  1982 00000797 C1E802              <2> 		shr	eax, 2				;eax = number of pages free
  1983 0000079A 39C8                <2> 		cmp	eax, ecx
  1984 0000079C 723A                <2> 		jb	.no_burst_FreePages
  1985                              <2> 		
  1986                              <2> 		;Move the free pages to the PT
  1987 0000079E 29C8                <2> 		sub	eax, ecx
  1988 000007A0 C1E002              <2> 		shl	eax, 2
  1989 000007A3 8906                <2> 		mov	[esi], eax				;FPT Stack pointer
  1990                              <2> 		
  1991 000007A5 01C6                <2> 		add	esi, eax
  1992 000007A7 81C604000000        <2> 		add	esi, 4			;first free page to get
  1993 000007AD 89D7                <2> 		mov	edi, edx
  1994 000007AF 81E700F0FFFF        <2> 		and	edi, 0FFFFF000h
  1995 000007B5 C1EF0A              <2> 		shr	edi, 10			;edi = address at first PTE
  1996 000007B8 668CD8              <2> 		mov	ax, ds
  1997 000007BB 8EC0                <2> 		mov	es, ax
  1998 000007BD 5A                  <2> 	pop	edx
  1999 000007BE 52                  <2> 	push	edx
  2000                              <2> 		.burst_allocate:
  2001 000007BF AD                  <2> 			lodsd
  2002 000007C0 09D0                <2> 			or	eax, edx
  2003 000007C2 AB                  <2> 			stosd
  2004                              <2> 			
  2005                              <2> 			;invalidate TLB
  2006 000007C3 89F8                <2> 			mov	eax, edi
  2007 000007C5 C1E80A              <2> 			shr	eax, 10
  2008 000007C8 0F0138              <2> 			invlpg	[eax]
  2009                              <2> 			
  2010 000007CB E2F2                <2> 		loop	.burst_allocate
  2011                              <2> 				
  2012                              <2> 		
  2013                              <2> 	;Done
  2014 000007CD 58                  <2> 	pop	eax
  2015 000007CE 5A                  <2> 	pop	edx
  2016 000007CF 9D                  <2> 	popf
  2017 000007D0 5E                  <2> 	pop	esi
  2018 000007D1 5F                  <2> 	pop	edi
  2019 000007D2 07                  <2> 	pop	es
  2020 000007D3 59                  <2> 	pop	ecx
  2021 000007D4 F8                  <2> 	clc
  2022 000007D5 C3                  <2> 	ret
  2023                              <2> 	
  2024                              <2> 	.no_burst_FreePages_pop:
  2025 000007D6 5A                  <2> 	pop	edx
  2026 000007D7 59                  <2> 	pop	ecx
  2027                              <2> 	.no_burst_FreePages:
  2028 000007D8 58                  <2> 	pop	eax
  2029 000007D9 5A                  <2> 	pop	edx
  2030 000007DA 9D                  <2> 	popf
  2031 000007DB 5E                  <2> 	pop	esi
  2032 000007DC 5F                  <2> 	pop	edi
  2033 000007DD 07                  <2> 	pop	es
  2034 000007DE 59                  <2> 	pop	ecx
  2035                              <2> 	;no enough(ecx) free pages left - out of memory
  2036 000007DF F9                  <2> 	stc
  2037 000007E0 C3                  <2> 	ret
  2038                              <2> 
  2039                              <2> 	
  2040                              <2> 
  2041                              <2> ;===============================================================================
  2042                              <2> 
  2043                              <2> ;page.popfree	;(eax = Free PTE) == ()
  2044                              <2>     
  2045                              <2> .popfree:	;get one free page
  2046 000007E1 9C                  <2> 	pushf
  2047 000007E2 53                  <2> 	push	ebx
  2048 000007E3 FA                  <2> 		cli
  2049                              <2> 		
  2050 000007E4 8B1D04004000        <2> 		mov	ebx, [System.lin_FPT]
  2051 000007EA 813B00000000        <2> 		cmp	dword [ebx], 0
  2052 000007F0 7414                <2> 		je	.noFreePages
  2053                              <2> 		
  2054 000007F2 812B04000000        <2> 		sub	dword [ebx], 4				;FPT Stack pointer
  2055 000007F8 031B                <2> 		add	ebx, [ebx]
  2056 000007FA 8B4304              <2> 		mov	eax, [ebx + 4]
  2057                              <2> 	
  2058 000007FD 5B                  <2> 	pop	ebx
  2059 000007FE 9D                  <2> 	popf
  2060 000007FF 0D01000000          <2> 	or	eax, 1					;set present bit
  2061 00000804 F8                  <2> 	clc
  2062 00000805 C3                  <2> 	ret
  2063                              <2> 	
  2064                              <2> 		.noFreePages:
  2065 00000806 5B                  <2> 	pop	ebx
  2066 00000807 9D                  <2> 	popf
  2067                              <2> 	;no fre pages left - out of memory
  2068 00000808 B800000000          <2> 	mov	eax, 0
  2069 0000080D F9                  <2> 	stc
  2070 0000080E C3                  <2> 	ret
  2071                              <2> 
  2072                              <2> ;===============================================================================
  2073                              <2> ;
  2074                              <2> ;page.dealloc	;() == (edx = Selector, ebx = Base, ecx = Size)
  2075                              <2> 
  2076                              <2> ;;;;
  2077                              <2> ;
  2078                              <2> ;	    INVLPG is necessary in all cases if the old PTE/PDE state was "present", and not necessary otherwise.
  2079                              <2> ;
  2080                              <2> ;;;;
  2081                              <2> ;    An optimization for freeing the PTEs:
  2082                              <2> ;
  2083                              <2> ;    - put the free PTEs not to free list, but to "dirty" list.
  2084                              <2> ;    - PTEs cannot be reallocated from the "dirty" list
  2085                              <2> ;    - when "dirty" list becomes too long - execute
  2086                              <2> ;
  2087                              <2> ;        mov    eax, cr3
  2088                              <2> ;        mov    cr3, eax
  2089                              <2> ;
  2090                              <2> ;    and then move the "dirty" list to the free list".
  2091                              <2> ;
  2092                              <2> ;    This saves time on INVLPG.
  2093                              <2> ;;;;
  2094                              <2> 	
  2095                              <2> .dealloc:
  2096                              <2>     ;Deallocates...
  2097                              <2> 
  2098 0000080F 50                  <2> 	push	eax
  2099 00000810 51                  <2> 	push	ecx
  2100 00000811 52                  <2> 	push	edx
  2101                              <2> 	        
  2102 00000812 E856FCFFFF          <2> 		call	desc.get_linear_base	;(eax = Linear Base) == (edx = Selector, ebx = Base, ecx = Size)
  2103 00000817 7208                <2> 		jc	.dealloc_done
  2104                              <2> 
  2105 00000819 89C2                <2> 		mov	edx, eax
  2106 0000081B E805000000          <2> 		call	page.dealloc_lin	;() == (edx = Base, ecx = Size)
  2107                              <2> 				
  2108 00000820 F8                  <2> 		clc
  2109                              <2> 	.dealloc_done:
  2110 00000821 5A                  <2> 	pop	edx	
  2111 00000822 59                  <2> 	pop	ecx
  2112 00000823 58                  <2> 	pop	eax
  2113 00000824 C3                  <2>     	ret
  2114                              <2> 
  2115                              <2> ;===============================================================================
  2116                              <2> ;
  2117                              <2> ;page.dealloc_lin	;() == (edx = Base, ecx = Size)
  2118                              <2> .dealloc_lin:
  2119 00000825 51                  <2> 	push	ecx
  2120 00000826 52                  <2> 	push	edx
  2121                              <2> 	        
  2122 00000827 81F900000000        <2> 		cmp	ecx, 0
  2123 0000082D 741D                <2> 		je	.dealloc_lin_done
  2124                              <2> 		
  2125 0000082F 01D1                <2> 		add	ecx, edx
  2126 00000831 81E200F0FFFF        <2> 		and	edx, 0FFFFF000h
  2127 00000837 29D1                <2> 		sub	ecx, edx
  2128 00000839 49                  <2> 		dec	ecx
  2129 0000083A C1E90C              <2> 		shr	ecx, 12			;ecx = number of pages
  2130 0000083D 41                  <2> 		inc	ecx
  2131                              <2> 		
  2132                              <2> 		.daealloc_loop:
  2133                              <2> 		
  2134 0000083E E80C000000          <2> 			call .removepage	;() == (edx = Linear Address)
  2135 00000843 81C200100000        <2> 			add	edx, 1000h
  2136                              <2> 		
  2137 00000849 E2F3                <2> 		loop .daealloc_loop
  2138                              <2> 		
  2139 0000084B F8                  <2> 		clc
  2140                              <2> 	.dealloc_lin_done:
  2141 0000084C 5A                  <2> 	pop	edx	
  2142 0000084D 59                  <2> 	pop	ecx
  2143 0000084E C3                  <2>     	ret
  2144                              <2> 
  2145                              <2> ;===============================================================================
  2146                              <2> 
  2147                              <2> ;page.removepage	;() == (edx = Linear Address)
  2148                              <2> 
  2149                              <2> .removepage
  2150                              <2> 	;edx = linear base
  2151 0000084F 50                  <2> 	push	eax
  2152                              <2> 		
  2153 00000850 E82D000000          <2> 		call .readpage		;(eax = PTE) == (edx = Linear Address)
  2154 00000855 720A                <2> 		jc	.removepage_done
  2155                              <2> 		
  2156 00000857 E808000000          <2> 		call .pushfree		;(eax = 0) == (eax = PTE to free)
  2157                              <2> 		
  2158 0000085C E82E000000          <2> 		call .writepage	;(edx = Linear Address, eax = PTE to write) == (edx = Linear Address, eax = PTE to write)
  2159                              <2> 		
  2160                              <2> 	.removepage_done:
  2161 00000861 58                  <2> 	pop	eax
  2162 00000862 F8                  <2> 	clc
  2163 00000863 C3                  <2> 	ret
  2164                              <2> 
  2165                              <2> ;===============================================================================
  2166                              <2> 
  2167                              <2> ;page.pushfree	;(eax = 0) == (eax = PTE to free)
  2168                              <2> 	
  2169                              <2> .pushfree: ;push one page to the free page stack
  2170                              <2> 	;in:		eax = page to return
  2171                              <2> 	;out:	eax = 0
  2172 00000864 53                  <2> 	push	ebx
  2173 00000865 8B1D04004000        <2> 		mov	ebx, [System.lin_FPT]
  2174 0000086B 810304000000        <2> 		add	dword [ebx], 4				;FPT Stack pointer
  2175                              <2> 
  2176 00000871 2500F0FFFF          <2> 		and	eax, 0FFFFF000h			;Remove settings
  2177                              <2> 		
  2178 00000876 031B                <2> 		add	ebx, [ebx]
  2179 00000878 8903                <2> 		mov	[ebx], eax				;return Page to stack
  2180                              <2> 		
  2181 0000087A 5B                  <2> 		pop	ebx
  2182 0000087B B800000000          <2> 	mov	eax, 0
  2183 00000880 F8                  <2> 	clc
  2184 00000881 C3                  <2> 	ret
  2185                              <2> 	
  2186                              <2> 	
  2187                              <2> ;===============================================================================
  2188                              <2> 
  2189                              <2> ;page.readpage	;(eax = PTE) == (edx = Linear Address)
  2190                              <2> 
  2191                              <2> .readpage:
  2192                              <2> 	;get page at linear address
  2193                              <2> 	;edx = linear base
  2194                              <2> 	;return eax = page at address
  2195                              <2> 
  2196 00000882 53                  <2> 	push	ebx
  2197                              <2> 	
  2198 00000883 E82E000000          <2> 	call	.get_PTE_address	;(ebx = PTE Pointer, edx = Linear Address) == (edx = Linear Address)
  2199 00000888 7204                <2> 	jc	.readpage_error
  2200 0000088A 8B03                <2> 	mov	eax, [ebx]	
  2201                              <2> 	
  2202 0000088C 5B                  <2> 	pop	ebx
  2203 0000088D F8                  <2> 	clc
  2204                              <2> 	.readpage_error:
  2205 0000088E C3                  <2> 	ret
  2206                              <2> 
  2207                              <2> ;===============================================================================
  2208                              <2> 
  2209                              <2> ;page.writepage	;(edx = Linear Address, eax = PTE to write) == (edx = Linear Address, eax = PTE to write) ! ("Out of memory")
  2210                              <2> 	
  2211                              <2> .writepage:
  2212                              <2> 	;edx = linear base
  2213                              <2> 	;eax = page to write
  2214                              <2> 	
  2215 0000088F 53                  <2> 	push	ebx
  2216                              <2> 
  2217 00000890 E821000000          <2> 		call	.get_PTE_address	;(ebx = PTE Pointer, edx = Linear Address) == (edx = Linear Address)
  2218 00000895 721C                <2> 		jc	.writepage_error
  2219                              <2> 		
  2220                              <2> 		;if page already exists?
  2221 00000897 813B00000000        <2> 		cmp	[ebx], dword 0
  2222 0000089D 7409                <2> 		je	.write_page_now
  2223                              <2> 			
  2224                              <2> 			;free page
  2225 0000089F 50                  <2> 			push	eax
  2226 000008A0 8B03                <2> 			mov	eax, [ebx]
  2227 000008A2 E8BDFFFFFF          <2> 			call	.pushfree	;(eax = 0) == (eax = PTE to free)	
  2228 000008A7 58                  <2> 			pop	eax
  2229                              <2> 		
  2230                              <2> 		.write_page_now:
  2231                              <2> 		
  2232                              <2> 		;write page(eax)
  2233 000008A8 8903                <2> 		mov	[ebx], eax
  2234                              <2> 
  2235                              <2> 		;invalidate TLB
  2236 000008AA C1EB0A              <2> 		shr	ebx, 10
  2237 000008AD 0F013B              <2> 		invlpg	[ebx]
  2238                              <2> 
  2239                              <2> 		
  2240 000008B0 5B                  <2> 	pop	ebx
  2241 000008B1 F8                  <2> 	clc
  2242 000008B2 C3                  <2> 	ret
  2243                              <2> 	
  2244                              <2> 	.writepage_error:
  2245 000008B3 5B                  <2> 	pop	ebx
  2246 000008B4 F9                  <2> 	stc
  2247 000008B5 C3                  <2> 	ret
  2248                              <2> 
  2249                              <2> 	
  2250                              <2> ;===============================================================================
  2251                              <2> 
  2252                              <2> ;page.get_PTE_address	;(ebx = PTE Pointer) == (edx = Linear Address)
  2253                              <2> 	;get address to the PTE of the linear address
  2254                              <2> 	;if PT doesn't exist it is created
  2255                              <2> 	
  2256                              <2> 	;in:		edx = linear address
  2257                              <2> 	;error:	out of memory
  2258                              <2> 
  2259                              <2> .get_PTE_address:
  2260 000008B6 E855000000          <2> 	call	.create_PT	;() == (edx = Linear Address)
  2261 000008BB 720D                <2> 	jc	.get_PTE_address_error
  2262                              <2> 	
  2263 000008BD 89D3                <2> 	mov	ebx, edx
  2264 000008BF 81E300F0FFFF        <2> 	and	ebx, 0FFFFF000h
  2265 000008C5 C1EB0A              <2> 	shr	ebx, 10
  2266 000008C8 F8                  <2> 	clc
  2267 000008C9 C3                  <2> 	ret
  2268                              <2> 	
  2269                              <2> .get_PTE_address_error:
  2270 000008CA F9                  <2> 	stc
  2271 000008CB C3                  <2> 	ret
  2272                              <2> 
  2273                              <2> 	
  2274                              <2> ;===============================================================================
  2275                              <2> 
  2276                              <2> ;page.allocate_PT	;() == (edx = linear address, ecx = size)
  2277                              <2> 	;Create a PT(if needed) for PT at linear address
  2278                              <2> 	
  2279                              <2> 	;in:		edx = linear address
  2280                              <2> 	;error:	out of memory
  2281                              <2> .allocate_PT:
  2282                              <2> 	
  2283                              <2> 		;Make sure all PT are allocated
  2284 000008CC 50                  <2> 	push	eax
  2285 000008CD 51                  <2> 	push	ecx
  2286 000008CE 52                  <2> 	push	edx
  2287 000008CF 81E200F0FFFF        <2> 		and	edx, 0FFFFF000h
  2288 000008D5 89D0                <2> 		mov	eax, edx		
  2289 000008D7 250000C0FF          <2> 		and	eax, 0FFC00000h	;eax = start PT address
  2290 000008DC 01CA                <2> 		add	edx, ecx
  2291 000008DE 29C2                <2> 		sub	edx, eax
  2292 000008E0 89D1                <2> 		mov	ecx, edx
  2293 000008E2 C1E916              <2> 		shr	ecx, 22	
  2294 000008E5 41                  <2> 		inc	ecx				;ecx = number of PT to check
  2295 000008E6 89C2                <2> 		mov	edx, eax			;edx = linear address at first memory of the first PT
  2296                              <2> 		
  2297                              <2> 		;Check size
  2298 000008E8 89C8                <2> 		mov	eax, ecx
  2299 000008EA C1E016              <2> 		shl	eax, 22	;eax = PT
  2300 000008ED 01D0                <2> 		add	eax, edx
  2301 000008EF 39D0                <2> 		cmp	eax, edx
  2302 000008F1 7218                <2> 		jb	.allocate_PT_error
  2303                              <2> 		
  2304                              <2> 		
  2305                              <2> 		.check_PT:
  2306 000008F3 E818000000          <2> 		call	page.create_PT	;() == (edx = Linear Address)
  2307 000008F8 0F82D8FEFFFF        <2> 			jc	.no_burst_FreePages_pop
  2308 000008FE 81C200004000        <2> 			add	edx, 400000h
  2309 00000904 E2ED                <2> 		loop	.check_PT
  2310 00000906 5A                  <2> 	pop	edx
  2311 00000907 59                  <2> 	pop	ecx
  2312 00000908 58                  <2> 	pop	eax
  2313                              <2> 	
  2314 00000909 F8                  <2> 	clc
  2315 0000090A C3                  <2> 	ret
  2316                              <2> 	
  2317                              <2> 	.allocate_PT_error:
  2318 0000090B 5A                  <2> 	pop	edx
  2319 0000090C 59                  <2> 	pop	ecx
  2320 0000090D 58                  <2> 	pop	eax
  2321                              <2> 
  2322 0000090E F9                  <2> 	stc
  2323 0000090F C3                  <2> 	ret
  2324                              <2> 	
  2325                              <2> ;===============================================================================
  2326                              <2> 
  2327                              <2> ;page.create_PT	;() == (edx = Linear Address)
  2328                              <2> 	;Create a PT(if needed) for PT at linear address
  2329                              <2> 	
  2330                              <2> 	;in:		edx = linear address
  2331                              <2> 	;error:	out of memory
  2332                              <2> 
  2333                              <2> .create_PT:
  2334 00000910 53                  <2> 	push	ebx	
  2335                              <2> 
  2336                              <2> 		;Check if PT exist
  2337 00000911 89D3                <2> 		mov	ebx, edx
  2338 00000913 C1EB14              <2> 		shr	ebx, 20			;Get Page Table index
  2339 00000916 81E3FC0F0000        <2> 		and	ebx, 0FFCh		;ebx = mem pointer at PD Entry
  2340 0000091C 0FBA2300            <2> 		bt dword [ebx], 0		;Check if PT Entry  exists
  2341 00000920 7233                <2> 		jc	.create_PT_done
  2342                              <2> 
  2343                              <2> 		;ignore size - assume 4kB
  2344                              <2> 					
  2345                              <2> 		;Page Table doesn't exist, make one
  2346                              <2> 		;[ebx] = page table entry
  2347 00000922 50                  <2> 		push	eax
  2348                              <2> 		
  2349                              <2> 			;get a free page
  2350 00000923 E8B9FEFFFF          <2> 			call	.popfree	;(eax = Free PTE) == ()
  2351 00000928 722E                <2> 			jc	.create_PT_error
  2352                              <2> 			
  2353                              <2> 			;write to table
  2354 0000092A 8903                <2> 			mov	[ebx], eax
  2355                              <2> 			
  2356                              <2> 			;invalidate TLB
  2357 0000092C C1EB0A              <2> 			shr	ebx, 10
  2358 0000092F 0F013B              <2> 			invlpg	[ebx]
  2359                              <2> 
  2360                              <2> 			;write zeros to table
  2361 00000932 57                  <2> 			push edi
  2362 00000933 51                  <2> 			push ecx
  2363 00000934 06                  <2> 			push	es
  2364                              <2> 			
  2365 00000935 89D7                <2> 				mov	edi, edx
  2366 00000937 81E70000C0FF        <2> 				and	edi, 0FFC00000h
  2367 0000093D C1EF0A              <2> 				shr	edi, 10
  2368 00000940 B900040000          <2> 				mov	ecx, 400h		;dwords in a PT
  2369 00000945 668CD8              <2> 				mov	ax, ds
  2370 00000948 8EC0                <2> 				mov	es, ax
  2371 0000094A B800000000          <2> 				mov	eax, 0
  2372 0000094F F3AB                <2> 				rep	stosd		;write zeros to table
  2373                              <2> 			
  2374 00000951 07                  <2> 			pop	es
  2375 00000952 59                  <2> 			pop	ecx
  2376 00000953 5F                  <2> 			pop	edi
  2377                              <2> 		
  2378 00000954 58                  <2> 		pop	eax
  2379                              <2> 		
  2380                              <2> 	.create_PT_done:
  2381 00000955 5B                  <2> 	pop	ebx
  2382 00000956 F8                  <2> 	clc
  2383 00000957 C3                  <2> 	ret
  2384                              <2> 		
  2385                              <2> 	  .create_PT_error:
  2386 00000958 58                  <2> 	  	pop	eax
  2387 00000959 5B                  <2> 	  	pop	ebx
  2388                              <2> 		;out of memory cant get address
  2389                              <2> 		;Can't create PD entry for specified address
  2390 0000095A F9                  <2> 		stc
  2391 0000095B C3                  <2> 		ret
  2392                              <2> 
  2393                              <2> 		
  2394                              <2> ;===============================================================================
  2395                              <2> 
  2396                              <2> ;page.getpaddress	;(ebx = physical address) == (edx = linear address)
  2397                              <2> ;	Get physical address from linear address
  2398                              <2> .getpaddress
  2399 0000095C 52                  <2> 	push	edx
  2400 0000095D E854FFFFFF          <2> 		call	.get_PTE_address	;(ebx = PTE Pointer) == (edx = Linear Address)
  2401 00000962 8B1B                <2> 		mov	ebx, [ebx]
  2402 00000964 81E300F0FFFF        <2> 		and	ebx, 0FFFFF000h
  2403 0000096A 81E2FF0F0000        <2> 		and	edx, 000000FFFh
  2404 00000970 09D3                <2> 		or	ebx, edx
  2405 00000972 5A                  <2> 	pop	edx
  2406                              <2> 
  2407                              <2> ;===============================================================================
  2408                              <2> ;
  2409                              <2> ;page.alias	;() == (int Source Selector, int Source Base, int Size, int Target Selector, int Target Base)
  2410                              <2> ;
  2411                              <2> ;	Map a linear memory area to the same physical memory as another lineary memory
  2412                              <2> ;
  2413                              <2> ; .alias:
  2414                              <2> ; 	push	ebx
  2415                              <2> ; 	push	ecx
  2416                              <2> ; 	push	edx
  2417                              <2> ; 	push	esi
  2418                              <2> ; 	push	edi
  2419                              <2> ; 		
  2420                              <2> ; 		;Source
  2421                              <2> ; 		mov	ax, [param1]
  2422                              <2> ; 		mov	ebx, [param2]
  2423                              <2> 
  2424                              <2> ; 		mov	ecx, [param3]	;ecx = size
  2425                              <2> ; 		add	ecx, 0FFFh
  2426                              <2> ; 		shr	ecx, 12
  2427                              <2> ; 		
  2428                              <2> ; 		call	desc.get_linear_base	;(edx = Linear Base, ax = Selector, ebx = Base, ecx = Size) == (ax = Selector, ebx = Base, ecx = Size) ! ("Out of Bounds")
  2429                              <2> ; 		jc	.alias_error
  2430                              <2> ; 		mov	esi, edx	;esi = source linear address
  2431                              <2> ; 		shr	esi, 10
  2432                              <2> ; 		and	esi, 3FFFFCh
  2433                              <2> ; 			
  2434                              <2> ; 		;Target
  2435                              <2> ; 		mov	ax, [param4]
  2436                              <2> ; 		mov	ebx, [param5]
  2437                              <2> ; 		call	desc.get_linear_base	;(edx = Linear Base, ax = Selector, ebx = Base, ecx = Size) == (ax = Selector, ebx = Base, ecx = Size) ! ("Out of Bounds")
  2438                              <2> ; 		jc	.alias_error
  2439                              <2> ; 		mov	edi, edx	;eid = target linear address
  2440                              <2> ; 		shr	edi, 10
  2441                              <2> ; 		and	edi, 3FFFFCh
  2442                              <2> 
  2443                              <2> ; 		push	es			
  2444                              <2> ; 			mov	ax, ds
  2445                              <2> ; 			mov	es, ax
  2446                              <2> ; 				
  2447                              <2> ; 			rep	movsd
  2448                              <2> ; 		pop	es
  2449                              <2> ; 	
  2450                              <2> ; 	pop	edi
  2451                              <2> ; 	pop	esi
  2452                              <2> ; 	pop	edx
  2453                              <2> ; 	pop	ecx
  2454                              <2> ; 	pop	ebx
  2455                              <2> ; 	
  2456                              <2> ; 	xor	eax, eax
  2457                              <2> ; 	clc
  2458                              <2> ; 	ret
  2459                              <2> ; 	
  2460                              <2> ; 	
  2461                              <2> ; 	.alias_error:
  2462                              <2> ; 	pop	edi
  2463                              <2> ; 	pop	esi
  2464                              <2> ; 	pop	edx
  2465                              <2> ; 	pop	ecx
  2466                              <2> ; 	pop	ebx
  2467                              <2> ; 	
  2468                              <2> ; 	mov	eax, -1
  2469                              <2> ; 	stc
  2470                              <2> ; 	ret
  2471                              <2> 	
  2472                              <2> 
  2473                              <2> ;===============================================================================
  2474                              <2> ;
  2475                              <2> ;page.phys_allocate		;() == (edx Selector, ebx Base, edi First PTE, ecx Size)
  2476                              <2> ;
  2477                              <2> ;	Allocate lineary memory with specified physical memory
  2478                              <2> ;
  2479                              <2> .phys_allocate:
  2480 00000973 50                  <2> 	push	eax
  2481 00000974 57                  <2> 	push	edi
  2482                              <2> 		
  2483 00000975 E8F3FAFFFF          <2> 		call	desc.get_linear_base	;(eax = Linear Base) == (edx = Selector, ebx = Base, ecx = Size)
  2484 0000097A 7217                <2> 		jc	.phys_allocate_error
  2485                              <2> 
  2486 0000097C 81E71AF0FFFF        <2> 		and	edi, 0FFFFF01Ah
  2487 00000982 81CF01000000        <2> 		or	edi, 1
  2488                              <2> 		
  2489 00000988 E80F000000          <2> 		call	.pallocate	;() == (eax Linear Base, edi First PTE, ecx Size)
  2490 0000098D 7204                <2> 		jc	.phys_allocate_error
  2491                              <2> 
  2492 0000098F 5F                  <2> 	pop	edi
  2493 00000990 58                  <2> 	pop	eax		
  2494 00000991 F8                  <2> 	clc
  2495 00000992 C3                  <2> 	ret
  2496                              <2> 		
  2497                              <2> 	.phys_allocate_error:
  2498 00000993 5F                  <2> 	pop	edi
  2499 00000994 81C404000000        <2> 	add	esp, 4	;pop	eax		;Keep eax=error code
  2500 0000099A F9                  <2> 	stc
  2501 0000099B C3                  <2> 	ret
  2502                              <2> 
  2503                              <2> ;===============================================================================
  2504                              <2> 
  2505                              <2> ;page.pallocate	;() == (eax Linear Base, edi First PTE, ecx Size)
  2506                              <2> ;	Allocate lineary memory with specified physical memory
  2507                              <2> 
  2508                              <2> .pallocate:
  2509 0000099C 52                  <2> 	push	edx
  2510 0000099D 57                  <2> 	push edi
  2511 0000099E 51                  <2> 	push ecx
  2512                              <2> 	
  2513 0000099F 89C2                <2> 		mov	edx, eax
  2514 000009A1 E826FFFFFF          <2> 		call	.allocate_PT	;() == (edx = linear address, ecx = size)
  2515 000009A6 722D                <2> 		jc	.pallocate_error
  2516                              <2> 	
  2517 000009A8 81CF01000000        <2> 		or	edi, 1		;Set present bit
  2518 000009AE C1EA0A              <2> 		shr	edx, 10
  2519 000009B1 81E2FCFF3F00        <2> 		and	edx, 3FFFFCh	;edx = PTE address
  2520 000009B7 81C1FF0F0000        <2> 		add	ecx, 0FFFh
  2521 000009BD C1E90C              <2> 		shr	ecx, 12		;ecx = pages
  2522                              <2> 		
  2523                              <2> 		.pallocate_loop:
  2524 000009C0 893A                <2> 		mov	[edx], edi
  2525 000009C2 81C204000000        <2> 		add	edx, 4
  2526 000009C8 81C700100000        <2> 		add	edi, 1000h
  2527 000009CE E2F0                <2> 		loop	.pallocate_loop
  2528                              <2> 
  2529 000009D0 59                  <2> 	pop	ecx
  2530 000009D1 5F                  <2> 	pop	edi
  2531 000009D2 5A                  <2> 	pop	edx
  2532                              <2> 		
  2533 000009D3 F8                  <2> 	clc
  2534 000009D4 C3                  <2> 	ret
  2535                              <2> 
  2536                              <2> 	.pallocate_error:
  2537 000009D5 59                  <2> 	pop	ecx
  2538 000009D6 5F                  <2> 	pop	edi
  2539 000009D7 5A                  <2> 	pop	edx
  2540                              <2> 		
  2541 000009D8 F9                  <2> 	stc
  2542 000009D9 C3                  <2> 	ret
  2543                              <1> %include 'mult.asm'
  2544                              <2> mult:
  2545                              <2> 
  2546                              <2> ;===============================================================================
  2547                              <2> ;
  2548                              <2> ;	mult.create		;(eax = Selector) == ()
  2549                              <2> ;
  2550                              <2> ;	Create a TSS(Process)
  2551                              <2> ;
  2552                              <2> .create:
  2553 000009DA 57                  <2> 	push	edi
  2554 000009DB 53                  <2> 	push	ebx		;ss
  2555 000009DC 51                  <2> 	push	ecx		;esp
  2556 000009DD 52                  <2> 	push	edx		;eip
  2557                              <2> 	
  2558 000009DE B800008900          <2> 		mov	eax, 00890000h	;eax16:31 = --------1Pl010B1
  2559 000009E3 B968000000          <2> 		mov	ecx, 68h			;size of TSS
  2560 000009E8 E88FF8FFFF          <2> 		call desc.create	;(eax Selector, edx Segment Base, ebx Desc Base) == (eax [Settings][Selector], ecx Size)
  2561 000009ED 0F829C000000        <2> 		jc near .create_error
  2562 000009F3 25FCFF0000          <2> 		and	eax, 0FFFCh
  2563 000009F8 50                  <2> 		push	eax			;Save Selector
  2564                              <2> 
  2565                              <2> 			;fill it with one page
  2566 000009F9 E8E3FDFFFF          <2> 			call	page.popfree	;(eax = Free PTE) == ()
  2567 000009FE 0F827B000000        <2> 			jc near .tss_error
  2568 00000A04 0D07000000          <2> 			or	eax, 0111b	;User,Writeable,Present
  2569 00000A09 E881FEFFFF          <2> 			call	page.writepage	;(edx = Linear Address, eax = PTE to wri) == (edx = Linear Address, eax = PTE to write)
  2570 00000A0E 730A                <2> 			jnc	.create_fill
  2571                              <2> 				
  2572                              <2> 			;Error ;return poped PTE
  2573 00000A10 E84FFEFFFF          <2> 			call	page.pushfree	;()==(eax = PTE)
  2574 00000A15 E965000000          <2> 			jmp	.tss_error
  2575                              <2> 			
  2576                              <2> 			.create_fill:
  2577                              <2> 		;This page contains:
  2578                              <2> 		
  2579                              <2> 			;fill whole page with zeros
  2580 00000A1A 06                  <2> 			push	es
  2581 00000A1B 668CD8              <2> 				mov	ax, ds
  2582 00000A1E 8EC0                <2> 				mov	es, ax
  2583                              <2> 				
  2584 00000A20 89D7                <2> 				mov	edi, edx
  2585 00000A22 B900040000          <2> 				mov	ecx, 1000h / 4
  2586 00000A27 31C0                <2> 				xor	eax, eax
  2587 00000A29 F3AB                <2> 				rep	stosd		;Fill TSS with zeros
  2588 00000A2B 07                  <2> 			pop	es		
  2589                              <2> 			
  2590                              <2> 		;TSS:
  2591                              <2> 					
  2592                              <2> 			;EFlags
  2593 00000A2C C7422402120000      <2> 			mov dword [edx + 24h], 00001202h	;IOPL=1, IF=1 
  2594                              <2> 						
  2595                              <2> 			;PDBR
  2596 00000A33 0F20D8              <2> 			mov	eax, cr3	
  2597 00000A36 89421C              <2> 			mov	[edx + 1Ch], eax
  2598                              <2> 			
  2599                              <2> 			;LDT, same as callers LDT
  2600 00000A39 0F004260            <2> 			sldt	[edx + 60h]
  2601                              <2> 		
  2602                              <2> 			;IObase
  2603 00000A3D 66C742666800        <2> 			mov word [edx + 66h], 68h	;at end of TSS
  2604                              <2> 				
  2605                              <2> 		;(Floating point memory, to store float registers during taskswitch) - nothing to write(already zeros)
  2606                              <2> 			;[edx + task_struc.Float], 512 bytes
  2607                              <2> 					
  2608 00000A43 89D7                <2> 			mov	edi, edx
  2609                              <2> 			
  2610                              <2> 		;Privile 0 Stack
  2611 00000A45 B804000000          <2> 			mov	eax, 0100b	;TI: 1=LDT
  2612 00000A4A E8DDF8FFFF          <2> 			call desc.create_desc	;(eax = selector, ebx = Desc Base) == (eax = selector)
  2613 00000A4F 7229                <2> 			jc	.tss_error_free
  2614                              <2> 			
  2615                              <2> 			;Data        -D-L----1Pl10EWA
  2616 00000A51 0D00009200          <2> 			or	eax, 00920000h
  2617 00000A56 B9000C0000          <2> 			mov	ecx, pages - task_struc.Stack		;the rest of the page
  2618 00000A5B 81C200040000        <2> 			add	edx, task_struc.Stack
  2619 00000A61 E8F3FAFFFF          <2> 			call	desc.write_desc	;(same) == (eax = [Settings][Selector], ebx = Desc Base, ecx = Size, edx = Base)
  2620                              <2> 			
  2621 00000A66 89FA                <2> 			mov	edx, edi
  2622 00000A68 66894208            <2> 			mov	[edx + 08h], ax		;SS0
  2623 00000A6C C74204FC0B0000      <2> 			mov dword [edx + 04h], pages - task_struc.Stack - 4	;ESP0
  2624                              <2> 
  2625                              <2> 			.tss_no_ss:
  2626                              <2> 		;return selector
  2627 00000A73 58                  <2> 		pop	eax
  2628 00000A74 5A                  <2> 	pop	edx
  2629 00000A75 59                  <2> 	pop	ecx
  2630 00000A76 5B                  <2> 	pop	ebx
  2631 00000A77 5F                  <2> 	pop	edi
  2632 00000A78 F8                  <2> 	clc
  2633 00000A79 C3                  <2> 	ret
  2634                              <2> 	
  2635                              <2> 
  2636                              <2> 		.tss_error_free:
  2637 00000A7A B900100000          <2> 			mov	ecx, pages
  2638                              <2> 				
  2639                              <2> 		.tss_error:
  2640 00000A7F 5A                  <2> 		pop	edx	;Selector
  2641 00000A80 E859FBFFFF          <2> 		call	desc.get_seg_base	;(ebx = Segment Base) == (dx = Selector)
  2642 00000A85 E8B6F9FFFF          <2> 		call	desc.delete_lin		;() == (ebx Base, ecx Size)
  2643 00000A8A E89DF9FFFF          <2> 		call	desc.delete_desc		;() == (edx Selector)
  2644                              <2> 		
  2645                              <2> 		.create_error
  2646 00000A8F 5A                  <2> 	pop	edx
  2647 00000A90 59                  <2> 	pop	ecx
  2648 00000A91 5B                  <2> 	pop	ebx
  2649 00000A92 5F                  <2> 	pop	edi
  2650 00000A93 F9                  <2> 	stc
  2651 00000A94 C3                  <2> 	ret
  2652                              <2> 
  2653                              <2> 	
  2654                              <2> ;===============================================================================
  2655                              <2> ;
  2656                              <2> ;mult.delete	;() == (edx Selector)
  2657                              <2> ;	Delete a TSS
  2658                              <2> ;
  2659                              <2> .delete:
  2660 00000A95 51                  <2> 	push	ecx
  2661 00000A96 53                  <2> 	push	ebx
  2662                              <2> 		;Close interface connected to task
  2663 00000A97 E8AA030000          <2> 		call	interface.delete_task		;() == (edx Task)
  2664                              <2> 		
  2665                              <2> 		;Check type
  2666 00000A9C 0F02DA              <2> 		lar	ebx, edx
  2667 00000A9F 753C                <2> 		jnz	.delete_error
  2668 00000AA1 81E3001D0800        <2> 		and	ebx, 00081D00h	;Mask type + Avail bit
  2669 00000AA7 81FB00090000        <2> 		cmp	ebx, 00000900h	;is it a TSS?, Avail = 0 - Not an interface
  2670 00000AAD 752E                <2> 		jne	.delete_error
  2671                              <2> 		
  2672                              <2> 		;Remove from TL
  2673 00000AAF E844020000          <2> 		call	mult.remove	;(eax Status) == (edx = TSS Selector)
  2674                              <2> 
  2675 00000AB4 E825FBFFFF          <2> 		call	desc.get_seg_base	;(ebx = Segment Base) == (dx = Selector)
  2676                              <2> 
  2677 00000AB9 52                  <2> 		push	edx	
  2678                              <2> 		;Free:
  2679 00000ABA 668B5360            <2> 			mov	dx, [ebx + 60h]	;LDT
  2680 00000ABE C1E210              <2> 			shl	edx, 10h
  2681 00000AC1 668B5308            <2> 			mov	dx, [ebx + 08h]	;SS0
  2682 00000AC5 E8F1F8FFFF          <2> 			call	desc.delete_module		;() == (edx [Module][Selector])
  2683 00000ACA 5A                  <2> 		pop	edx
  2684                              <2> 		
  2685                              <2> 		;Remove segment
  2686 00000ACB B900100000          <2> 		mov	ecx, pages
  2687 00000AD0 E86BF9FFFF          <2> 		call	desc.delete_lin		;() == (ebx Base, ecx Size)
  2688                              <2> 		
  2689                              <2> 		;Remove descriptor
  2690 00000AD5 E852F9FFFF          <2> 		call	desc.delete_desc		;() == (edx Selector)
  2691                              <2> 		
  2692 00000ADA 5B                  <2> 	pop	ebx
  2693 00000ADB 59                  <2> 	pop	ecx
  2694 00000ADC C3                  <2> 	ret
  2695                              <2> 
  2696                              <2> 	.delete_error:
  2697 00000ADD 5B                  <2> 	pop	ebx
  2698 00000ADE 59                  <2> 	pop	ecx
  2699 00000ADF F9                  <2> 	stc
  2700 00000AE0 C3                  <2> 	ret
  2701                              <2> 
  2702                              <2> 
  2703                              <2> ;=======================
  2704                              <2> %macro	move 1
  2705                              <2> 		mov	ebx, [esi + (%1)]
  2706                              <2> 		mov	[es:edi + (%1)], ebx
  2707                              <2> %endmacro
  2708                              <2> %macro	moveseg 1
  2709                              <2> 		mov	bx, [esi + (%1)]
  2710                              <2> 		mov	[es:edi + (%1)], bx
  2711                              <2> %endmacro
  2712                              <2> %macro	moveseg 2
  2713                              <2> 		mov	bx, [esi + (%1)]
  2714                              <2> 		arpl	bx, %2
  2715                              <2> 		mov	[es:edi + (%1)], bx
  2716                              <2> %endmacro
  2717                              <2> 
  2718                              <2> ;===============================================================================
  2719                              <2> ;
  2720                              <2> ;	mult.get			;() == (edx TSS Selector, ds:ebx TSS segment data)
  2721                              <2> ;
  2722                              <2> .get:
  2723 00000AE1 50                  <2> 	push	eax
  2724 00000AE2 53                  <2> 	push	ebx
  2725 00000AE3 56                  <2> 	push	esi
  2726 00000AE4 57                  <2> 	push	edi
  2727 00000AE5 06                  <2> 	push	es
  2728 00000AE6 368B450C            <2> 		mov	eax, [caller_cs]
  2729                              <2> 		
  2730                              <2> 		;Get Target
  2731 00000AEA 89DF                <2> 		mov	edi, ebx
  2732 00000AEC 36668B5D04          <2> 		mov	bx, [caller_ds]
  2733 00000AF1 63C3                <2> 		arpl	bx, ax
  2734 00000AF3 8EC3                <2> 		mov	es, bx	;es:edi = Target
  2735                              <2> 
  2736                              <2> 		;Get TSS Base
  2737 00000AF5 E8C4FAFFFF          <2> 		call	desc.get_tss_base	;(ebx = Base) == (dx = Selector)
  2738 00000AFA 0F82BA000000        <2> 		jc near .get_error
  2739 00000B00 89DE                <2> 		mov	esi, ebx	;ds:esi = TSS segment
  2740                              <2> 		
  2741                              <2> 		;test Module
  2742 00000B02 0F00C3              <2> 		sldt	bx
  2743 00000B05 663B5E60            <2> 		cmp	bx, [esi + 60h]	;ldt
  2744 00000B09 0F85AB000000        <2> 		jne near .get_error		;TSS LDT must be same as current LDT
  2745                              <2> 		
  2746                              <2> 		;Test CPL
  2747 00000B0F 88C3                <2> 		mov	bl, al	;bl = [caller_cs]
  2748 00000B11 80E303              <2> 		and	bl, 011b	;bl = CPL
  2749 00000B14 80FB03              <2> 		cmp	bl, 3
  2750 00000B17 7425                <2> 		je	.get_3
  2751 00000B19 80FB02              <2> 		cmp	bl, 2
  2752 00000B1C 7410                <2> 		je	.get_2
  2753                              <2> 		;else CPL = 1, since 0 is kernel only
  2754                              <2> 		
  2755                              <2> 	;CPL 0:
  2756                              <2> ;	[- I/O map    -][-           -]T 64h
  2757                              <2> ;	[-            -][-    LDT     -] 60h
  2758                              <2> ;	[            EFlags            ] 24h
  2759                              <2> ;	[            EIP               ] 20h
  2760                              <2> ;	[-           CR3 PDBR         -] 1Ch
  2761                              <2> ;	[-            -][-   SS0      -] 08h
  2762                              <2> ;	[-            ESP0            -] 04h
  2763                              <2> ;	[-            -][    Link      ] 00h
  2764                              <2> 
  2765                              <2> 
  2766                              <2> 		.get_1:
  2767                              <2> 		moveseg	10h		;ss2
  2768 00000B1E 668B5E10            <3>  mov bx, [esi + (%1)]
  2769 00000B22 2666895F10          <3>  mov [es:edi + (%1)], bx
  2770                              <2> 		move		0Ch		;esp2
  2771 00000B27 8B5E0C              <3>  mov ebx, [esi + (%1)]
  2772 00000B2A 26895F0C            <3>  mov [es:edi + (%1)], ebx
  2773                              <2> 				
  2774                              <2> 		.get_2:
  2775                              <2> 		moveseg	18h		;ss2
  2776 00000B2E 668B5E18            <3>  mov bx, [esi + (%1)]
  2777 00000B32 2666895F18          <3>  mov [es:edi + (%1)], bx
  2778                              <2> 		move		14h		;esp2
  2779 00000B37 8B5E14              <3>  mov ebx, [esi + (%1)]
  2780 00000B3A 26895F14            <3>  mov [es:edi + (%1)], ebx
  2781                              <2> 			
  2782                              <2> 		.get_3:
  2783                              <2> 		move	20h	;EIP
  2784 00000B3E 8B5E20              <3>  mov ebx, [esi + (%1)]
  2785 00000B41 26895F20            <3>  mov [es:edi + (%1)], ebx
  2786                              <2> 		move	28h	;eax
  2787 00000B45 8B5E28              <3>  mov ebx, [esi + (%1)]
  2788 00000B48 26895F28            <3>  mov [es:edi + (%1)], ebx
  2789                              <2> 		move	2Ch	;ecx
  2790 00000B4C 8B5E2C              <3>  mov ebx, [esi + (%1)]
  2791 00000B4F 26895F2C            <3>  mov [es:edi + (%1)], ebx
  2792                              <2> 		move	30h	;edx
  2793 00000B53 8B5E30              <3>  mov ebx, [esi + (%1)]
  2794 00000B56 26895F30            <3>  mov [es:edi + (%1)], ebx
  2795                              <2> 		move	34h	;ebx
  2796 00000B5A 8B5E34              <3>  mov ebx, [esi + (%1)]
  2797 00000B5D 26895F34            <3>  mov [es:edi + (%1)], ebx
  2798                              <2> 		move	38h	;esp
  2799 00000B61 8B5E38              <3>  mov ebx, [esi + (%1)]
  2800 00000B64 26895F38            <3>  mov [es:edi + (%1)], ebx
  2801                              <2> 		move	3Ch	;ebp
  2802 00000B68 8B5E3C              <3>  mov ebx, [esi + (%1)]
  2803 00000B6B 26895F3C            <3>  mov [es:edi + (%1)], ebx
  2804                              <2> 		move	40h	;esi
  2805 00000B6F 8B5E40              <3>  mov ebx, [esi + (%1)]
  2806 00000B72 26895F40            <3>  mov [es:edi + (%1)], ebx
  2807                              <2> 		move	44h	;edi
  2808 00000B76 8B5E44              <3>  mov ebx, [esi + (%1)]
  2809 00000B79 26895F44            <3>  mov [es:edi + (%1)], ebx
  2810                              <2> 		moveseg	48h	;es
  2811 00000B7D 668B5E48            <3>  mov bx, [esi + (%1)]
  2812 00000B81 2666895F48          <3>  mov [es:edi + (%1)], bx
  2813                              <2> 		moveseg	4Ch	;cs
  2814 00000B86 668B5E4C            <3>  mov bx, [esi + (%1)]
  2815 00000B8A 2666895F4C          <3>  mov [es:edi + (%1)], bx
  2816                              <2> 		moveseg	50h	;ss
  2817 00000B8F 668B5E50            <3>  mov bx, [esi + (%1)]
  2818 00000B93 2666895F50          <3>  mov [es:edi + (%1)], bx
  2819                              <2> 		moveseg	54h	;ds
  2820 00000B98 668B5E54            <3>  mov bx, [esi + (%1)]
  2821 00000B9C 2666895F54          <3>  mov [es:edi + (%1)], bx
  2822                              <2> 		moveseg	58h	;fs
  2823 00000BA1 668B5E58            <3>  mov bx, [esi + (%1)]
  2824 00000BA5 2666895F58          <3>  mov [es:edi + (%1)], bx
  2825                              <2> 		moveseg	5Ch	;gs
  2826 00000BAA 668B5E5C            <3>  mov bx, [esi + (%1)]
  2827 00000BAE 2666895F5C          <3>  mov [es:edi + (%1)], bx
  2828 00000BB3 07                  <2> 	pop	es
  2829 00000BB4 5F                  <2> 	pop	edi
  2830 00000BB5 5E                  <2> 	pop	esi
  2831 00000BB6 5B                  <2> 	pop	ebx
  2832 00000BB7 58                  <2> 	pop	eax
  2833 00000BB8 F8                  <2> 	clc
  2834 00000BB9 C3                  <2> 	ret
  2835                              <2> 	
  2836                              <2> 	.get_error
  2837 00000BBA 07                  <2> 	pop	es
  2838 00000BBB 5F                  <2> 	pop	edi
  2839 00000BBC 5E                  <2> 	pop	esi
  2840 00000BBD 5B                  <2> 	pop	ebx
  2841 00000BBE 58                  <2> 	pop	eax
  2842 00000BBF F9                  <2> 	stc
  2843 00000BC0 C3                  <2> 	ret
  2844                              <2> 
  2845                              <2> ;===============================================================================
  2846                              <2> ;
  2847                              <2> ;	mult.set			;() == (edx TSS Selector, ds:ebx TSS segment data)
  2848                              <2> ;
  2849                              <2> .set:
  2850 00000BC1 50                  <2> 	push	eax
  2851 00000BC2 53                  <2> 	push	ebx
  2852 00000BC3 56                  <2> 	push	esi
  2853 00000BC4 57                  <2> 	push	edi
  2854 00000BC5 1E                  <2> 	push	ds
  2855 00000BC6 06                  <2> 	push	es
  2856 00000BC7 368B450C            <2> 		mov	eax, [caller_cs]
  2857                              <2> 
  2858                              <2> 		;Get TSS Data
  2859 00000BCB 89DE                <2> 		mov	esi, ebx
  2860                              <2> 		
  2861                              <2> 		;Get Target
  2862 00000BCD E8ECF9FFFF          <2> 		call	desc.get_tss_base	;(ebx = Base) == (dx = Selector)
  2863 00000BD2 0F82CD000000        <2> 		jc near .set_error
  2864 00000BD8 1E                  <2> 		push	ds
  2865 00000BD9 07                  <2> 		pop	es
  2866 00000BDA 89DF                <2> 		mov	edi, ebx	;es:edi = TSS segment
  2867                              <2> 
  2868                              <2> 		;Get TSS Data
  2869 00000BDC 36668B5D04          <2> 		mov	bx, [caller_ds]
  2870 00000BE1 63C3                <2> 		arpl	bx, ax
  2871 00000BE3 8EDB                <2> 		mov	ds, bx	;ds:esi = Source
  2872                              <2> 		
  2873                              <2> 		;test Module
  2874 00000BE5 0F00C3              <2> 		sldt	bx
  2875 00000BE8 26663B5F60          <2> 		cmp	bx, [es:edi + 60h]	;ldt
  2876 00000BED 0F85B2000000        <2> 		jne near .set_error		;TSS LDT must be same as current LDT
  2877                              <2> 		
  2878                              <2> 		;Test CPL
  2879 00000BF3 88C3                <2> 		mov	bl, al	;bl = [caller_cs]
  2880 00000BF5 80E303              <2> 		and	bl, 011b	;bl = CPL
  2881 00000BF8 80FB03              <2> 		cmp	bl, 3
  2882 00000BFB 7429                <2> 		je	.set_3
  2883 00000BFD 80FB02              <2> 		cmp	bl, 2
  2884 00000C00 7412                <2> 		je	.set_2
  2885                              <2> 		;else CPL = 1, since 0 is kernel only
  2886                              <2> 		
  2887                              <2> 	;CPL 0:
  2888                              <2> ;	[- I/O map    -][-           -]T 64h
  2889                              <2> ;	[-            -][-    LDT     -] 60h
  2890                              <2> ;	[            EFlags            ] 24h
  2891                              <2> ;	[            EIP               ] 20h
  2892                              <2> ;	[-           CR3 PDBR         -] 1Ch
  2893                              <2> ;	[-            -][-   SS0      -] 08h
  2894                              <2> ;	[-            ESP0            -] 04h
  2895                              <2> ;	[-            -][    Link      ] 00h
  2896                              <2> 
  2897                              <2> 		;moveseg assume eax = [caller_cs]
  2898                              <2> 		.set_1:
  2899                              <2> 		moveseg	10h, ax	;ss2
  2900 00000C02 668B5E10            <3>  mov bx, [esi + (%1)]
  2901 00000C06 63C3                <3>  arpl bx, %2
  2902 00000C08 2666895F10          <3>  mov [es:edi + (%1)], bx
  2903                              <2> 		move		0Ch		;esp2
  2904 00000C0D 8B5E0C              <3>  mov ebx, [esi + (%1)]
  2905 00000C10 26895F0C            <3>  mov [es:edi + (%1)], ebx
  2906                              <2> 				
  2907                              <2> 		.set_2:
  2908                              <2> 		moveseg	18h, ax	;ss2
  2909 00000C14 668B5E18            <3>  mov bx, [esi + (%1)]
  2910 00000C18 63C3                <3>  arpl bx, %2
  2911 00000C1A 2666895F18          <3>  mov [es:edi + (%1)], bx
  2912                              <2> 		move		14h		;esp2
  2913 00000C1F 8B5E14              <3>  mov ebx, [esi + (%1)]
  2914 00000C22 26895F14            <3>  mov [es:edi + (%1)], ebx
  2915                              <2> 			
  2916                              <2> 		.set_3:
  2917                              <2> 		move	20h	;EIP
  2918 00000C26 8B5E20              <3>  mov ebx, [esi + (%1)]
  2919 00000C29 26895F20            <3>  mov [es:edi + (%1)], ebx
  2920                              <2> 		move	28h	;eax
  2921 00000C2D 8B5E28              <3>  mov ebx, [esi + (%1)]
  2922 00000C30 26895F28            <3>  mov [es:edi + (%1)], ebx
  2923                              <2> 		move	2Ch	;ecx
  2924 00000C34 8B5E2C              <3>  mov ebx, [esi + (%1)]
  2925 00000C37 26895F2C            <3>  mov [es:edi + (%1)], ebx
  2926                              <2> 		move	30h	;edx
  2927 00000C3B 8B5E30              <3>  mov ebx, [esi + (%1)]
  2928 00000C3E 26895F30            <3>  mov [es:edi + (%1)], ebx
  2929                              <2> 		move	34h	;ebx
  2930 00000C42 8B5E34              <3>  mov ebx, [esi + (%1)]
  2931 00000C45 26895F34            <3>  mov [es:edi + (%1)], ebx
  2932                              <2> 		move	38h	;esp
  2933 00000C49 8B5E38              <3>  mov ebx, [esi + (%1)]
  2934 00000C4C 26895F38            <3>  mov [es:edi + (%1)], ebx
  2935                              <2> 		move	3Ch	;ebp
  2936 00000C50 8B5E3C              <3>  mov ebx, [esi + (%1)]
  2937 00000C53 26895F3C            <3>  mov [es:edi + (%1)], ebx
  2938                              <2> 		move	40h	;esi
  2939 00000C57 8B5E40              <3>  mov ebx, [esi + (%1)]
  2940 00000C5A 26895F40            <3>  mov [es:edi + (%1)], ebx
  2941                              <2> 		move	44h	;edi
  2942 00000C5E 8B5E44              <3>  mov ebx, [esi + (%1)]
  2943 00000C61 26895F44            <3>  mov [es:edi + (%1)], ebx
  2944                              <2> 		moveseg	48h	;es
  2945 00000C65 668B5E48            <3>  mov bx, [esi + (%1)]
  2946 00000C69 2666895F48          <3>  mov [es:edi + (%1)], bx
  2947                              <2> 		moveseg	4Ch, ax	;cs
  2948 00000C6E 668B5E4C            <3>  mov bx, [esi + (%1)]
  2949 00000C72 63C3                <3>  arpl bx, %2
  2950 00000C74 2666895F4C          <3>  mov [es:edi + (%1)], bx
  2951                              <2> 		moveseg	50h	;ss
  2952 00000C79 668B5E50            <3>  mov bx, [esi + (%1)]
  2953 00000C7D 2666895F50          <3>  mov [es:edi + (%1)], bx
  2954                              <2> 		moveseg	54h	;ds
  2955 00000C82 668B5E54            <3>  mov bx, [esi + (%1)]
  2956 00000C86 2666895F54          <3>  mov [es:edi + (%1)], bx
  2957                              <2> 		moveseg	58h	;fs
  2958 00000C8B 668B5E58            <3>  mov bx, [esi + (%1)]
  2959 00000C8F 2666895F58          <3>  mov [es:edi + (%1)], bx
  2960                              <2> 		moveseg	5Ch	;gs
  2961 00000C94 668B5E5C            <3>  mov bx, [esi + (%1)]
  2962 00000C98 2666895F5C          <3>  mov [es:edi + (%1)], bx
  2963 00000C9D 07                  <2> 	pop	es
  2964 00000C9E 1F                  <2> 	pop	ds
  2965 00000C9F 5F                  <2> 	pop	edi
  2966 00000CA0 5E                  <2> 	pop	esi
  2967 00000CA1 5B                  <2> 	pop	ebx
  2968 00000CA2 58                  <2> 	pop	eax
  2969 00000CA3 F8                  <2> 	clc
  2970 00000CA4 C3                  <2> 	ret
  2971                              <2> 	
  2972                              <2> 	.set_error
  2973 00000CA5 07                  <2> 	pop	es
  2974 00000CA6 1F                  <2> 	pop	ds
  2975 00000CA7 5F                  <2> 	pop	edi
  2976 00000CA8 5E                  <2> 	pop	esi
  2977 00000CA9 5B                  <2> 	pop	ebx
  2978 00000CAA 58                  <2> 	pop	eax
  2979 00000CAB F9                  <2> 	stc
  2980 00000CAC C3                  <2> 	ret
  2981                              <2> 
  2982                              <2> ;===============================================================================
  2983                              <2> ;
  2984                              <2> ;mult.add	;() == (dx = TSS Selector)
  2985                              <2> 
  2986                              <2> .add:
  2987 00000CAD 53                  <2> 	push	ebx
  2988 00000CAE 51                  <2> 	push	ecx
  2989 00000CAF 52                  <2> 	push	edx
  2990                              <2> 		
  2991 00000CB0 81E2F8FF0000        <2> 		and	edx, 0000FFF8h
  2992                              <2> 		
  2993                              <2> 		;Make sure it is a TSS
  2994 00000CB6 E803F9FFFF          <2> 		call	desc.get_tss_base	;(ebx = Base) == (dx = Selector)
  2995 00000CBB 7231                <2> 		jc	.add_error		;Selector is not a TSS Selector
  2996                              <2> 		
  2997                              <2> 		;Make sure it isn't already in the list
  2998 00000CBD E8AD000000          <2> 		call	.TL_scan	;(ebx = Entry Pointer, ecx = Entries Left) == (dx = TSS Selector)
  2999 00000CC2 7325                <2> 		jnc	.add_done
  3000                              <2> 
  3001                              <2> 		;in:	dx = TSS Selector
  3002 00000CC4 BB00204000          <2> 		mov	ebx, multitasking_struc.Head
  3003 00000CC9 8B4304              <2> 		mov	eax, [ebx+multitasking_struc.last]		;eax = pointer at last entry
  3004                              <2> 		
  3005                              <2> 		;Make sure it isn't the last one = no space left
  3006 00000CCC 0504000000          <2> 		add	eax, multitasking_struc.Entry_Size
  3007 00000CD1 3DF00F0000          <2> 		cmp	eax, multitasking_struc.Size
  3008 00000CD6 7316                <2> 		jae	.add_error
  3009                              <2> 
  3010                              <2> 		;add to list
  3011 00000CD8 894304              <2> 		mov	[ebx+multitasking_struc.last], eax	
  3012 00000CDB BB10204000          <2> 		mov	ebx, multitasking_struc.Base
  3013 00000CE0 01C3                <2> 		add	ebx, eax
  3014 00000CE2 668913              <2> 		mov	[ebx+multitasking_struc.current], dx
  3015 00000CE5 66895302            <2> 		mov	[ebx+multitasking_struc.original], dx
  3016                              <2> 		
  3017                              <2> 	.add_done:
  3018 00000CE9 5A                  <2> 	pop	edx
  3019 00000CEA 59                  <2> 	pop	ecx
  3020 00000CEB 5B                  <2> 	pop	ebx
  3021                              <2> 	;Done, return
  3022 00000CEC F8                  <2> 	clc
  3023 00000CED C3                  <2> 	ret
  3024                              <2> 
  3025                              <2> 	.add_error:
  3026 00000CEE 5A                  <2> 	pop	edx
  3027 00000CEF 59                  <2> 	pop	ecx
  3028 00000CF0 5B                  <2> 	pop	ebx
  3029                              <2> 
  3030 00000CF1 B850000000          <2> 	mov	eax, err_TL_Full
  3031 00000CF6 F9                  <2> 	stc
  3032 00000CF7 C3                  <2> 	ret
  3033                              <2> 
  3034                              <2> 
  3035                              <2> 	
  3036                              <2> ;===============================================================================
  3037                              <2> ;
  3038                              <2> ;mult.remove	;(eax Status) == (edx = TSS Selector)
  3039                              <2> 
  3040                              <2> .remove:
  3041 00000CF8 53                  <2> 	push	ebx
  3042 00000CF9 51                  <2> 	push	ecx
  3043 00000CFA 52                  <2> 	push	edx
  3044 00000CFB 56                  <2> 	push	esi
  3045 00000CFC 57                  <2> 	push	edi
  3046 00000CFD 9C                  <2> 	pushfd
  3047 00000CFE FA                  <2> 		cli	;Disable Interrupts
  3048                              <2> 		
  3049 00000CFF 81E2F8FF0000        <2> 		and	edx, 0000FFF8h
  3050                              <2> 		
  3051                              <2> 
  3052 00000D05 E865000000          <2> 		call	.TL_scan	;(ebx = Entry Pointer, ecx = Entries Left) == (dx = TSS Selector)
  3053 00000D0A 7255                <2> 		jc	.remove_error
  3054                              <2> 
  3055                              <2> 		;Make sure task is in current ldt(module)
  3056                              <2> 		
  3057                              <2> 		;Test Task type
  3058 00000D0C 663B5302            <2> 		cmp	dx, [ebx+multitasking_struc.original]	;interface if not equal
  3059 00000D10 754F                <2> 		jne	.remove_error	;can't remove interfaces
  3060                              <2> 						
  3061                              <2> 		;remove process
  3062                              <2> 		
  3063                              <2> 		;move entries
  3064 00000D12 BA00204000          <2> 		mov	edx, multitasking_struc.Head
  3065 00000D17 8B02                <2> 		mov	eax, [edx + multitasking_struc.current]
  3066 00000D19 0510204000          <2> 		add	eax, multitasking_struc.Base
  3067 00000D1E 39D8                <2> 		cmp	eax, ebx
  3068 00000D20 760A                <2> 		jbe	.remove_below
  3069                              <2> 		
  3070                              <2> 			;Decrease by one entry
  3071 00000D22 812D10204000040000- <2> 			sub dword [multitasking_struc.Base+multitasking_struc.current], multitasking_struc.Entry_Size
  3072 00000D2B 00                  <2>
  3073                              <2> 			
  3074                              <2> 		.remove_below:
  3075                              <2> 		;eax = pointer at current
  3076                              <2> 		;ebx = pointer at entry to be removed
  3077                              <2> 		;edx = multitasking_struc.Base
  3078                              <2> 				
  3079                              <2> 		;move the rest one step to the left
  3080 00000D2C 89DF                <2> 		mov	edi, ebx
  3081 00000D2E 89DE                <2> 		mov	esi, ebx
  3082 00000D30 81C604000000        <2> 		add	esi, multitasking_struc.Entry_Size
  3083 00000D36 F3A5                <2> 		rep	movsd
  3084                              <2> 		
  3085                              <2> 		;decrease last Entry
  3086 00000D38 816A0404000000      <2> 		sub dword [edx+multitasking_struc.last], multitasking_struc.Entry_Size
  3087                              <2> 	
  3088                              <2> 	;Test if current
  3089 00000D3F 39D8                <2> 		cmp	eax, ebx	;current equal removed?
  3090 00000D41 7514                <2> 		jne	.remove_done
  3091                              <2> 			
  3092 00000D43 89D8                <2> 			mov	eax, ebx
  3093 00000D45 2D04000000          <2> 			sub	eax, multitasking_struc.Entry_Size
  3094 00000D4A 2D10204000          <2> 			sub	eax, multitasking_struc.Base
  3095 00000D4F 8B5204              <2> 			mov	edx, [edx+multitasking_struc.last]
  3096                              <2> 			;eax = current(no base)
  3097                              <2> 			;edx = last(no base)
  3098 00000D52 E810040000          <2> 			call	Multitasking.NextTask
  3099                              <2> 	
  3100                              <2> 	.remove_done:
  3101 00000D57 9D                  <2> 	popfd	;Enable Interrupts(if it were enabled before)
  3102 00000D58 5F                  <2> 	pop	edi
  3103 00000D59 5E                  <2> 	pop	esi
  3104 00000D5A 5A                  <2> 	pop	edx
  3105 00000D5B 59                  <2> 	pop	ecx
  3106 00000D5C 5B                  <2> 	pop	ebx	
  3107 00000D5D 31C0                <2> 	xor	eax, eax	
  3108 00000D5F F8                  <2> 	clc
  3109 00000D60 C3                  <2> 	ret
  3110                              <2> 
  3111                              <2> 	.remove_error:
  3112                              <2> 		;TSS not found
  3113 00000D61 B800000000          <2> 		mov	eax, 0
  3114 00000D66 EB00                <2> 		jmp short .remove_error_return
  3115                              <2> 		
  3116                              <2> 	.remove_error_interface:
  3117                              <2> 		
  3118                              <2> 	.remove_error_return:		
  3119 00000D68 9D                  <2> 	popfd	;Enable Interrupts(if it were enabled before)
  3120 00000D69 5F                  <2> 	pop	edi
  3121 00000D6A 5E                  <2> 	pop	esi
  3122 00000D6B 59                  <2> 	pop	ecx
  3123 00000D6C 5B                  <2> 	pop	ebx
  3124 00000D6D F9                  <2> 	stc
  3125 00000D6E C3                  <2> 	ret
  3126                              <2> 	
  3127                              <2> 
  3128                              <2> ;===============================================================================
  3129                              <2> 
  3130                              <2> ;mult.TL_scan	;(ebx = Entry Pointer, ecx = Entries Left) == (dx = TSS Selector)
  3131                              <2> 
  3132                              <2> .TL_scan:
  3133                              <2> ;Scan the list for dx(= TSS selector) and return
  3134                              <2> ;Used to find a specific Task
  3135                              <2> ;Return:	ebx = pointer att found Entry
  3136                              <2> ;		ecx = number of entries to the end of the list
  3137                              <2> 
  3138 00000D6F BB00204000          <2> 	mov	ebx, multitasking_struc.Head
  3139 00000D74 8B4B04              <2> 	mov	ecx, [ebx+multitasking_struc.last]		;Last Entry
  3140 00000D77 C1E902              <2> 	shr	ecx, multitasking_struc.Entry_Size_2
  3141 00000D7A BB10204000          <2> 	mov	ebx, multitasking_struc.Base
  3142                              <2> 	
  3143 00000D7F 81F900000000        <2> 	cmp	ecx, 0	;is the list empty?
  3144 00000D85 740D                <2> 	je	.TL_scan_NotFound
  3145                              <2> 	
  3146                              <2> 	.TL_scan_Loop:
  3147 00000D87 81C304000000        <2> 	add	ebx, multitasking_struc.Entry_Size	;Jumps over the first entry = idle entry
  3148 00000D8D 663B13              <2> 	cmp	dx,	[ebx]
  3149 00000D90 7404                <2> 	je	.TL_scan_Found
  3150 00000D92 E0F3                <2> 	loopne .TL_scan_Loop
  3151                              <2> 
  3152                              <2> 	.TL_scan_NotFound:
  3153 00000D94 F9                  <2> 	stc		;Error: Entry not found
  3154 00000D95 C3                  <2> 	ret
  3155                              <2> 
  3156                              <2> 	.TL_scan_Found:
  3157 00000D96 49                  <2> 	dec	ecx
  3158 00000D97 F8                  <2> 	clc
  3159 00000D98 C3                  <2> 	ret
  3160                              <2> 
  3161                              <2> 	
  3162                              <1> %include 'interface.asm'
  3163                              <2> ;
  3164                              <2> ; Interface management
  3165                              <2> ;
  3166                              <2> ;
  3167                              <2> interface:
  3168                              <2> 
  3169                              <2> ;===============================================================================
  3170                              <2> ;
  3171                              <2> ;interface.create	;() == (edx Type, ebx Process(TSS selector))
  3172                              <2> 
  3173                              <2> ;	Create an In-interface
  3174                              <2> 
  3175                              <2> .create:
  3176 00000D99 51                  <2> 	push	ecx
  3177 00000D9A 53                  <2> 	push	ebx
  3178 00000D9B 52                  <2> 	push	edx
  3179                              <2> 		
  3180 00000D9C E8C3010000          <2> 		call	interface.get_interface_base	;(ebx Base) == ()
  3181 00000DA1 B910000000          <2> 		mov	ecx, module_struc.InterfaceCount
  3182                              <2> 	
  3183 00000DA6 81CA01000000        <2> 		or	edx, interface_struc.Type_present	;set present bit
  3184                              <2> 	
  3185                              <2> 		.scan:
  3186 00000DAC 3913                <2> 			cmp	[ebx + interface_struc.Type], edx
  3187 00000DAE 7461                <2> 			je	.create_error
  3188 00000DB0 0FBA2B01            <2> 			bts dword	[ebx + interface_struc.Type], interface_struc.Type_present
  3189 00000DB4 730D                <2> 			jnc	.found_free
  3190 00000DB6 81C308000000        <2> 			add	ebx, module_struc.InterfaceEntSize
  3191 00000DBC E2EE                <2> 		loop	.scan
  3192 00000DBE E94E000000          <2> 		jmp	.create_error	;found no free entries
  3193                              <2> 				
  3194                              <2> 		;Create new
  3195                              <2> 		.found_free:
  3196                              <2> 		
  3197                              <2> 		;Write Type
  3198 00000DC3 8913                <2> 		mov	[ebx + interface_struc.Type], edx
  3199                              <2> 		
  3200                              <2> 		;Test if out-type
  3201 00000DC5 0FBAE202            <2> 		bt	edx, interface_struc.Type_in_interface
  3202 00000DC9 7330                <2> 		jnc	.create_out
  3203                              <2> 		
  3204 00000DCB 368B542404          <2> 		mov	edx, [ss:esp + 4]	;TSS selector
  3205                              <2> 		
  3206 00000DD0 53                  <2> 		push	ebx
  3207                              <2> 	
  3208                              <2> 			;Is running?
  3209 00000DD1 E899FFFFFF          <2> 			call	mult.TL_scan	;(ebx = Entry Pointer, ecx = Entries Left) == (dx = TSS Selector)
  3210 00000DD6 7334                <2> 			jnc	.create_error_int
  3211                              <2> 		
  3212                              <2> 			;check TSS
  3213 00000DD8 0F02CA              <2> 			lar	ecx, edx
  3214 00000DDB 752F                <2> 			jnz	.create_error_int	;not found, error
  3215 00000DDD 81E1009F1000        <2> 			and	ecx, 00109F00h		;		Busy: 0
  3216 00000DE3 81F900890000        <2> 			cmp	ecx, 00008900h		;		Interface: 0	(Avail bit)
  3217 00000DE9 7521                <2> 			jne	.create_error_int
  3218                              <2> 			
  3219                              <2> 			
  3220 00000DEB E842F7FFFF          <2> 			call	desc.get_desc_base	;(ebx = Base) == (dx = selector)
  3221 00000DF0 0FBA6B0414          <2> 			bts dword [ebx+4], 14h	;Set Interface bit
  3222                              <2> 
  3223 00000DF5 5B                  <2> 		pop	ebx
  3224                              <2> 					
  3225 00000DF6 E902000000          <2> 		jmp	.create_in
  3226                              <2> 				
  3227                              <2> 		.create_out:
  3228 00000DFB 31D2                <2> 		xor	edx, edx
  3229                              <2> 		.create_in:
  3230 00000DFD 66895306            <2> 		mov	[ebx + interface_struc.TSS], dx
  3231                              <2> 		.create_in_out:
  3232 00000E01 31D2                <2> 		xor	edx, edx
  3233 00000E03 66895304            <2> 		mov	[ebx + interface_struc.Module], dx	;Write Connected module/Calling TSS(= 0)
  3234                              <2> 		
  3235 00000E07 5A                  <2> 	pop	edx
  3236 00000E08 5B                  <2> 	pop	ebx
  3237 00000E09 59                  <2> 	pop	ecx
  3238 00000E0A F8                  <2> 	clc
  3239 00000E0B C3                  <2> 	ret
  3240                              <2> 	
  3241                              <2> 		
  3242                              <2> 		.create_error_int:	;TSS error, not a TSS or "busy" TSS
  3243 00000E0C 5B                  <2> 		pop	ebx
  3244                              <2> 		;Clear type field in interface
  3245 00000E0D 31D2                <2> 		xor	edx, edx
  3246 00000E0F 8913                <2> 		mov	[ebx + interface_struc.Type], edx
  3247                              <2> 	
  3248                              <2> 	.create_error:
  3249 00000E11 5A                  <2> 	pop	edx
  3250 00000E12 5B                  <2> 	pop	ebx
  3251 00000E13 59                  <2> 	pop	ecx
  3252 00000E14 F9                  <2> 	stc
  3253 00000E15 C3                  <2> 	ret
  3254                              <2> 		
  3255                              <2> ;===============================================================================
  3256                              <2> ;
  3257                              <2> ;	interface.delete		;() == (edx Type)
  3258                              <2> ;
  3259                              <2> ;	Delete an interface
  3260                              <2> 
  3261                              <2> .delete:
  3262 00000E16 53                  <2> 	push	ebx
  3263 00000E17 50                  <2> 	push	eax
  3264 00000E18 E847010000          <2> 		call	interface.get_interface_base	;(ebx Base) == ()
  3265                              <2> 	
  3266                              <2> 		;scan for type(edx)
  3267                              <2> 		.delete_scan:
  3268 00000E1D 3913                <2> 			cmp	[ebx + interface_struc.Type], edx
  3269 00000E1F 740D                <2> 			je	.delete_found
  3270 00000E21 81C308000000        <2> 			add	ebx, module_struc.InterfaceEntSize
  3271 00000E27 E2F4                <2> 		loop	.delete_scan
  3272 00000E29 E914000000          <2> 		jmp	.delete_error	;found no free entries
  3273                              <2> 		
  3274                              <2> 		.delete_found:
  3275                              <2> 		;Called from .delete_task
  3276                              <2> 		;[ebx] = Interface entry
  3277                              <2> 		
  3278                              <2> 		;Disconnect interface
  3279 00000E2E 53                  <2> 		push	ebx
  3280 00000E2F 0F00C3              <2> 			sldt	bx
  3281 00000E32 E8F3000000          <2> 			call	interface.disconnect		;() == (edx Type, ebx module)
  3282 00000E37 5B                  <2> 		pop	ebx				
  3283                              <2> 		
  3284                              <2> 		;Remove Interface
  3285                              <2> 		%if module_struc.InterfaceEntSize != 8
  3286                              <2> 			%error "InterfaceEntSize changed"
  3287                              <2> 		%endif
  3288 00000E38 31C0                <2> 		xor	eax, eax
  3289 00000E3A 8903                <2> 		mov	[ebx], eax
  3290 00000E3C 894304              <2> 		mov	[ebx+4], eax
  3291                              <2> 		
  3292 00000E3F 58                  <2> 	pop	eax
  3293 00000E40 5B                  <2> 	pop	ebx
  3294 00000E41 C3                  <2> 	ret
  3295                              <2> 	
  3296                              <2> 	.delete_error:
  3297 00000E42 58                  <2> 	pop	eax
  3298 00000E43 5B                  <2> 	pop	ebx
  3299 00000E44 F9                  <2> 	stc
  3300 00000E45 C3                  <2> 	ret
  3301                              <2> 
  3302                              <2> 
  3303                              <2> ;===============================================================================
  3304                              <2> ;
  3305                              <2> ;	interface.delete_task		;() == (edx Task)
  3306                              <2> ;
  3307                              <2> ;	Delete an interface, given a task
  3308                              <2> 
  3309                              <2> .delete_task:
  3310 00000E46 53                  <2> 	push	ebx
  3311 00000E47 50                  <2> 	push	eax
  3312 00000E48 E817010000          <2> 		call	interface.get_interface_base	;(ebx Base) == ()
  3313                              <2> 	
  3314                              <2> 		;scan for type(edx)
  3315                              <2> 		.delete_task_scan:
  3316 00000E4D 0FBA2302            <2> 			bt dword [ebx + interface_struc.Type], interface_struc.Type_in_interface
  3317 00000E51 7306                <2> 			jnc	.delete_task_scan_next
  3318 00000E53 66395306            <2> 			cmp	[ebx + interface_struc.TSS], dx
  3319 00000E57 740A                <2> 			je	.delete_task_found
  3320                              <2> 			.delete_task_scan_next:
  3321 00000E59 81C308000000        <2> 			add	ebx, module_struc.InterfaceEntSize
  3322 00000E5F E2EC                <2> 		loop	.delete_task_scan
  3323 00000E61 EBDF                <2> 		jmp	.delete_error	;found no free entries
  3324                              <2> 		
  3325                              <2> 		.delete_task_found:
  3326                              <2> 		;[ebx] = Interface entry
  3327 00000E63 8B13                <2> 		mov	edx, [ebx + interface_struc.Type]
  3328 00000E65 EBC7                <2> 		jmp	.delete_found
  3329                              <2> 
  3330                              <2> 
  3331                              <2> ;===============================================================================
  3332                              <2> ;
  3333                              <2> ;	interface.connect		;() == (edx Type, ebx [source][target] module)
  3334                              <2> ;
  3335                              <2> ;	Makes an connection of type, from source module to target module
  3336                              <2> ;
  3337                              <2> .connect:
  3338 00000E67 60                  <2> 	pusha
  3339 00000E68 89D9                <2> 		mov	ecx, ebx
  3340                              <2> 		
  3341                              <2> 		;Disconnect source interface
  3342 00000E6A 89CB                <2> 		mov	ebx, ecx
  3343 00000E6C C1EB10              <2> 		shr	ebx, 10h
  3344 00000E6F 81E2FDFFFFFF        <2> 		and	edx, ~(interface_struc.Type_in_interface)
  3345 00000E75 E8B0000000          <2> 		call	interface.disconnect		;() == (edx Type, ebx module)
  3346 00000E7A 0F82A7000000        <2> 		jc near .connect_error
  3347                              <2> 			
  3348                              <2> 		;Disconnect target interface
  3349 00000E80 89CB                <2> 		mov	ebx, ecx
  3350 00000E82 81E3FFFF0000        <2> 		and	ebx, 0FFFFh
  3351 00000E88 81CA02000000        <2> 		or	edx, interface_struc.Type_in_interface
  3352 00000E8E E897000000          <2> 		call	interface.disconnect		;() == (edx Type, ebx module)
  3353 00000E93 0F828E000000        <2> 		jc near .connect_error
  3354                              <2> 		
  3355                              <2> 			
  3356                              <2> 		;Get Source Interface Base
  3357 00000E99 89CA                <2> 		mov	edx, ecx
  3358 00000E9B C1EA10              <2> 		shr	edx, 10h
  3359 00000E9E E8FBF6FFFF          <2> 		call	desc.get_ldt_base	;(ebx = Base) == (edx = Selector)
  3360 00000EA3 0F827E000000        <2> 		jc near .connect_error	;LDT error
  3361 00000EA9 81C380FFFFFF        <2> 		add	ebx, module_struc.Interface - module_struc.LDT
  3362 00000EAF 89DE                <2> 		mov	esi, ebx
  3363                              <2> 	
  3364                              <2> 		;Get Target Interface Base
  3365 00000EB1 89CA                <2> 		mov	edx, ecx
  3366 00000EB3 81E3FFFF0000        <2> 		and	ebx, 0FFFFh
  3367 00000EB9 E8E0F6FFFF          <2> 		call	desc.get_ldt_base	;(ebx = Base) == (edx = Selector)
  3368 00000EBE 0F8263000000        <2> 		jc near .connect_error	;LDT error
  3369 00000EC4 81C380FFFFFF        <2> 		add	ebx, module_struc.Interface - module_struc.LDT
  3370 00000ECA 89DF                <2> 		mov	edi, ebx
  3371                              <2> 		
  3372                              <2> 		
  3373                              <2> 		;Scan Source for edx
  3374 00000ECC 89F3                <2> 		mov	ebx, esi
  3375 00000ECE B910000000          <2> 		mov	ecx, module_struc.InterfaceCount
  3376 00000ED3 81E2FDFFFFFF        <2> 		and	edx, ~(interface_struc.Type_in_interface)
  3377                              <2> 		.connect_source_scan:
  3378 00000ED9 3913                <2> 			cmp	[ebx + interface_struc.Type], edx
  3379 00000EDB 740D                <2> 			je	.connect_source_found
  3380 00000EDD 81C308000000        <2> 			add	ebx, module_struc.InterfaceEntSize
  3381 00000EE3 E2F4                <2> 		loop	.connect_source_scan
  3382 00000EE5 E93D000000          <2> 		jmp	.connect_error	;found no free entries
  3383                              <2> 		.connect_source_found:
  3384 00000EEA 89DE                <2> 		mov	esi, ebx		
  3385                              <2> 
  3386                              <2> 		;Scan Target for edx
  3387 00000EEC 89FB                <2> 		mov	ebx, edi
  3388 00000EEE B910000000          <2> 		mov	ecx, module_struc.InterfaceCount
  3389 00000EF3 81CA02000000        <2> 		or	edx, interface_struc.Type_in_interface
  3390                              <2> 		.connect_target_scan:
  3391 00000EF9 3913                <2> 			cmp	[ebx + interface_struc.Type], edx
  3392 00000EFB 740D                <2> 			je	.connect_target_found
  3393 00000EFD 81C308000000        <2> 			add	ebx, module_struc.InterfaceEntSize
  3394 00000F03 E2F4                <2> 		loop	.connect_target_scan
  3395 00000F05 E91D000000          <2> 		jmp	.connect_error	;found no free entries
  3396                              <2> 		.connect_target_found:
  3397 00000F0A 89DF                <2> 		mov	edi, ebx
  3398                              <2> 
  3399                              <2> 		;Write interface data:
  3400                              <2> 		;Target:
  3401                              <2> 		;	.Module = source module
  3402                              <2> 		;Source:
  3403                              <2> 		;	.TSS = target TSS
  3404 00000F0C C1E910              <2> 		shr	ecx, 10h
  3405 00000F0F 81E1F8FF0000        <2> 		and	ecx, 0FFF8h	;source module
  3406 00000F15 3E66894F04          <2> 		mov	[ds:edi + interface_struc.Module], cx
  3407 00000F1A 3E668B5706          <2> 		mov	dx, [ds:edi + interface_struc.TSS]
  3408 00000F1F 3E66895606          <2> 		mov	[ds:esi + interface_struc.TSS], dx
  3409                              <2> 
  3410 00000F24 61                  <2> 	popa
  3411 00000F25 F8                  <2> 	clc		
  3412 00000F26 C3                  <2> 	ret
  3413                              <2> 
  3414                              <2> 	
  3415                              <2> 	.connect_error:
  3416 00000F27 61                  <2> 	popa
  3417 00000F28 F9                  <2> 	stc
  3418 00000F29 C3                  <2> 	ret
  3419                              <2> ;===============================================================================
  3420                              <2> ;
  3421                              <2> ;	interface.disconnect		;() == (edx Type, ebx module)
  3422                              <2> ;	Removes an connection of type from module
  3423                              <2> .disconnect:
  3424                              <2> 	
  3425 00000F2A C3                  <2> 	ret
  3426                              <2> 
  3427                              <2> ;===============================================================================
  3428                              <2> ;
  3429                              <2> ;	interface.call		;() == (edx Type)
  3430                              <2> ;
  3431                              <2> ;	Call an interface
  3432                              <2> ;
  3433                              <2> .call:
  3434 00000F2B 53                  <2> 	push	ebx
  3435 00000F2C 51                  <2> 	push	ecx
  3436 00000F2D E832000000          <2> 		call	interface.get_interface_base	;(ebx Base) == ()
  3437                              <2> 		
  3438                              <2> 		;Scan for edx
  3439 00000F32 B910000000          <2> 		mov	ecx, module_struc.InterfaceCount
  3440 00000F37 81CA02000000        <2> 		or	edx, interface_struc.Type_in_interface
  3441                              <2> 		.call_scan:
  3442 00000F3D 3913                <2> 			cmp	[ebx + interface_struc.Type], edx
  3443 00000F3F 740D                <2> 			je	.call_found
  3444 00000F41 81C308000000        <2> 			add	ebx, module_struc.InterfaceEntSize
  3445 00000F47 E2F4                <2> 		loop	.call_scan
  3446 00000F49 E911000000          <2> 		jmp	.call_error	;found no matching entry
  3447                              <2> 		.call_found:
  3448                              <2> 
  3449                              <2> 		;Write Calling TSS
  3450 00000F4E 0F004B04            <2> 		str	[ebx + interface_struc.Caller]
  3451                              <2> 		
  3452                              <2> 		;Make the call
  3453 00000F52 FF5B06              <2> 		call	far [ebx + interface_struc.TSS]
  3454                              <2> 		
  3455                              <2> 		;Write Calling TSS
  3456 00000F55 66C743040000        <2> 		mov word [ebx + interface_struc.Caller], 0
  3457                              <2> 		
  3458 00000F5B 59                  <2> 	pop	ecx
  3459 00000F5C 5B                  <2> 	pop	ebx
  3460 00000F5D F8                  <2> 	clc
  3461 00000F5E C3                  <2> 	ret
  3462                              <2> 	
  3463                              <2> 	.call_error:
  3464 00000F5F 59                  <2> 	pop	ecx
  3465 00000F60 5B                  <2> 	pop	ebx
  3466 00000F61 F9                  <2> 	stc
  3467 00000F62 C3                  <2> 	ret
  3468                              <2> 	
  3469                              <2> ;===============================================================================
  3470                              <2> ;
  3471                              <2> ;interface.get_param		;(eax Caller) == (edx Interface_Type)
  3472                              <2> ;	Get interface status
  3473                              <2> ;	In:
  3474                              <2> ;		int	Interface ID
  3475                              <2> ;	Return:	int	Status
  3476                              <2> .get_param:
  3477                              <2> ;Read Status
  3478                              <2> ;Return:	Caller(if any)
  3479                              <2> 
  3480                              <2> 
  3481                              <2> ;===============================================================================
  3482                              <2> ;
  3483                              <2> ;interface.abort		;(eax Caller) == (edx Interface_Type)
  3484                              <2> ;	Abort an active interface connection
  3485                              <2> ;	In:
  3486                              <2> ;		int	Interface ID
  3487                              <2> ;	Return:	int	Status
  3488                              <2> .abort:
  3489                              <2> ;Read Status
  3490                              <2> ;Return:	Caller(if any)
  3491 00000F63 C3                  <2> 	ret
  3492                              <2> 
  3493                              <2> 	
  3494                              <2> 	
  3495                              <2> 	
  3496                              <2> ;===============================================================================
  3497                              <2> ;
  3498                              <2> ;	interface.get_interface_base	;(ebx Base) == ()
  3499                              <2> ;
  3500                              <2> .get_interface_base:
  3501 00000F64 52                  <2> 	push	edx
  3502                              <2> 		;Get LDT Base
  3503 00000F65 0F00C2              <2> 		sldt	dx
  3504 00000F68 E831F6FFFF          <2> 		call	desc.get_ldt_base	;(ebx = Base) == (dx = Selector)
  3505 00000F6D 7207                <2> 		jc	.get_base_error	;LDT error???
  3506                              <2> 		
  3507                              <2> 		;Get Interface Base
  3508 00000F6F 81C380FFFFFF        <2> 		add	ebx, module_struc.Interface - module_struc.LDT
  3509 00000F75 5A                  <2> 	pop	edx
  3510                              <2> 	
  3511                              <2> 	.get_base_error
  3512 00000F76 5A                  <2> 	pop	edx
  3513 00000F77 F9                  <2> 	stc
  3514 00000F78 C3                  <2> 	ret
  3515                              <2> 	
  3516                              <2> 	
  3517                              <2> 	
  3518                              <1> %include 'module.asm'
  3519                              <2> ;
  3520                              <2> ; Module management
  3521                              <2> ;
  3522                              <2> ;
  3523                              <2> module:
  3524                              <2> 
  3525                              <2> ;===============================================================================
  3526                              <2> ;
  3527                              <2> ;	module.create		;(eax Selector) == (ecx LDT Size)
  3528                              <2> ;	Create A module
  3529                              <2> 
  3530                              <2> .create:
  3531 00000F79 53                  <2> 	push	ebx
  3532 00000F7A 51                  <2> 	push	ecx
  3533 00000F7B 52                  <2> 	push	edx
  3534                              <2> 		;Size
  3535 00000F7C C1E103              <2> 		shl	ecx, 3	;8 bytes per desc
  3536                              <2> 				
  3537                              <2> 		;Descriptor
  3538 00000F7F 31C0                <2> 		xor	eax, eax	
  3539 00000F81 E8A6F3FFFF          <2> 		call	desc.create_desc	;(eax = selector, ebx = Desc Base) == (eax = selector)
  3540 00000F86 0F8291000000        <2> 		jc near .create_error
  3541                              <2> 		
  3542 00000F8C 50                  <2> 		push	eax	;save selector
  3543                              <2> 
  3544                              <2> 			;Linear memory
  3545 00000F8D 81C100010000        <2> 			add	ecx, module_struc.LDT
  3546 00000F93 E8C0F6FFFF          <2> 			call desc.alloc_mem	;(edx = Base, ecx = Size) == (ecx = Size(even 4kB) )
  3547 00000F98 7272                <2> 			jc	.create_error_desc
  3548                              <2> 
  3549                              <2> 			;Pages
  3550 00000F9A B803000000          <2> 			mov	eax, 3	;Present, writeable
  3551 00000F9F 51                  <2> 			push	ecx
  3552 00000FA0 49                  <2> 				dec	ecx
  3553 00000FA1 C1E90C              <2> 				shr	ecx, 12
  3554 00000FA4 41                  <2> 				inc	ecx
  3555 00000FA5 E8D2F7FFFF          <2> 				call	page.popfree_burst		;() == ;(eax = Settings, edx = Linear Address, ecx = pages)
  3556 00000FAA 59                  <2> 			pop	ecx
  3557 00000FAB 7258                <2> 				jc	.create_error_lin
  3558                              <2> 			
  3559                              <2> 			;Write Module data
  3560 00000FAD 57                  <2> 			push	edi
  3561 00000FAE 51                  <2> 			push	ecx
  3562                              <2> 				;Name
  3563 00000FAF C7026E657720        <2> 				mov dword [edx+module_struc.Name+0], 'new '
  3564 00000FB5 C74204756E6E61      <2> 				mov dword [edx+module_struc.Name+4], 'unna'
  3565 00000FBC C742086D656420      <2> 				mov dword [edx+module_struc.Name+8], 'med '
  3566 00000FC3 C7420C6D6F6420      <2> 				mov dword [edx+module_struc.Name+12], 'mod '
  3567                              <2> 				
  3568                              <2> 				;Interface list
  3569 00000FCA B800000000          <2> 				mov	eax, 0
  3570 00000FCF B920000000          <2> 				mov	ecx, module_struc.InterfaceSize / 4
  3571 00000FD4 89D7                <2> 				mov	edi, edx
  3572 00000FD6 81C780000000        <2> 				add	edi, module_struc.Interface
  3573 00000FDC 06                  <2> 				push	es
  3574 00000FDD 1E                  <2> 					push	ds
  3575 00000FDE 07                  <2> 					pop	es
  3576 00000FDF F3AB                <2> 					rep	stosd
  3577 00000FE1 07                  <2> 				pop	es
  3578 00000FE2 59                  <2> 			pop	ecx
  3579 00000FE3 5F                  <2> 			pop	edi
  3580                              <2> 							
  3581 00000FE4 58                  <2> 		pop	eax	;retrieve descriptor
  3582                              <2> 				
  3583                              <2> 		;Write Desc
  3584 00000FE5 81E900010000        <2> 		sub	ecx, module_struc.LDT
  3585 00000FEB 81C200010000        <2> 		add	edx, module_struc.LDT
  3586 00000FF1 0D00008200          <2> 		or	eax, 00820000h		;LDT		---A----1Pl00010 00000000 00000000
  3587 00000FF6 E85EF5FFFF          <2> 		call desc.write_desc	;(same) == (eax = [Settings][Selector], ebx = Desc Base, ecx = Size, edx = Base)
  3588                              <2> 		
  3589 00000FFB 5A                  <2> 	pop	edx	
  3590 00000FFC 59                  <2> 	pop	ecx
  3591 00000FFD 5B                  <2> 	pop	ebx
  3592                              <2> 	
  3593                              <2> 	;Done
  3594 00000FFE 25FCFF0000          <2> 	and	eax, 0FFFCh
  3595 00001003 F8                  <2> 	clc
  3596 00001004 C3                  <2> 	ret
  3597                              <2> 
  3598                              <2> 	
  3599                              <2> 			.create_error_lin:	
  3600                              <2> 			;dealloc lineary memory
  3601 00001005 89D3                <2> 			mov	ebx, edx
  3602 00001007 E89DF6FFFF          <2> 			call	desc.free_mem	;() == (ebx = lineary address, ecx = size)
  3603                              <2> 
  3604                              <2> 			.create_error_desc:	
  3605 0000100C 58                  <2> 		pop	eax
  3606                              <2> 		;remove the allocated descriptor
  3607 0000100D C70300000000        <2> 		mov dword [ebx], 0
  3608 00001013 C7430400000000      <2> 		mov dword [ebx+4], 0
  3609                              <2> 		
  3610 0000101A 5A                  <2> 	pop	edx	
  3611 0000101B 59                  <2> 	pop	ecx
  3612 0000101C 5B                  <2> 	pop	ebx
  3613                              <2> 		
  3614                              <2> 	.create_error:
  3615 0000101D 31C0                <2> 	xor	eax, eax
  3616 0000101F F9                  <2> 	stc
  3617 00001020 C3                  <2> 	ret
  3618                              <2> 
  3619                              <2> 	
  3620                              <2> 	
  3621                              <2> 
  3622                              <2> ;===============================================================================
  3623                              <2> ;
  3624                              <2> ;	module.delete		;() == (edx Selector)
  3625                              <2> ;	Delete a module
  3626                              <2> 
  3627                              <2> .delete:
  3628 00001021 57                  <2> 	push	edi
  3629 00001022 53                  <2> 	push ebx
  3630 00001023 51                  <2> 	push	ecx
  3631 00001024 81E2F8FF0000        <2> 		and	edx, 0FFF8h	
  3632 0000102A 89D7                <2> 		mov	edi, edx		;edi = module selector
  3633                              <2> 		
  3634 0000102C 0F02D7              <2> 		lar	edx, edi
  3635 0000102F 81E2009F0000        <2> 		and	edx, 00009F00h
  3636 00001035 81FA00820000        <2> 		cmp	edx, 00008200h
  3637 0000103B 7572                <2> 		jne	.delete_error
  3638                              <2> 		
  3639                              <2> 		;Scan GDT for TSS		
  3640 0000103D 31D2                <2> 		xor	edx, edx
  3641 0000103F E8A6F4FFFF          <2> 		call	desc.get_table	;(ebx = Table Base, ecx = Table Limit) == (dx = Selector(TI bit) )
  3642                              <2> 	
  3643 00001044 81E907000000        <2> 		sub	ecx, 7
  3644 0000104A C1E903              <2> 		shr	ecx, 3
  3645 0000104D 7419                <2> 		jz	.delete_scan_GDT_done
  3646 0000104F BA00000000          <2> 		mov	edx, 0
  3647                              <2> 		.delete_scan_GDT:
  3648 00001054 83C208              <2> 			add	edx, byte 8
  3649                              <2> 			;check if in correct module(edi)
  3650 00001057 E882F5FFFF          <2> 			call	desc.get_seg_base	;(ebx = Segment Base) == (dx = Selector)
  3651 0000105C 397B60              <2> 			cmp	[ebx + 60h], edi
  3652 0000105F 7505                <2> 			jne	.delete_scan_GDT_not
  3653                              <2> 				;delete Task
  3654 00001061 E82FFAFFFF          <2> 				call	mult.delete	;() == (edx Selector)
  3655                              <2> 			.delete_scan_GDT_not:
  3656 00001066 E2EC                <2> 			loop	.delete_scan_GDT
  3657                              <2> 		.delete_scan_GDT_done:
  3658                              <2> 		;all tasks in module deleted
  3659                              <2> 
  3660                              <2> 				
  3661                              <2> 		;Scan LDT for Data/Code
  3662 00001068 B204                <2> 		mov	dl, 4
  3663 0000106A E87BF4FFFF          <2> 		call	desc.get_table	;(ebx = Table Base, ecx = Table Limit) == (dx = Selector(TI bit) )
  3664 0000106F 41                  <2> 		inc	ecx
  3665 00001070 51                  <2> 		push	ecx
  3666 00001071 C1E903              <2> 			shr	ecx, 3
  3667 00001074 740F                <2> 			jz	.delete_scan_LDT_done
  3668                              <2> 			
  3669 00001076 89FA                <2> 			mov	edx, edi
  3670 00001078 C1E210              <2> 			shl	edx, 10h
  3671                              <2> 			.delete_scan_LDT:
  3672                              <2> 				;Remove Segment
  3673 0000107B E83BF3FFFF          <2> 				call	desc.delete_module		;() == (edx [Module][Selector])
  3674                              <2> 
  3675 00001080 83C208              <2> 				add	edx, byte 8
  3676 00001083 E2F6                <2> 				loop	.delete_scan_LDT
  3677                              <2> 			.delete_scan_LDT_done:
  3678 00001085 59                  <2> 		pop	ecx
  3679                              <2> 		;ecx = LDT Size
  3680                              <2> 		;ebx = LDT Base
  3681                              <2> 		
  3682                              <2> 		;Scan Interface list
  3683 00001086 53                  <2> 		push	ebx
  3684 00001087 51                  <2> 		push	ecx
  3685 00001088 81C380FFFFFF        <2> 			add	ebx, module_struc.Interface - module_struc.LDT
  3686 0000108E B910000000          <2> 			mov	ecx, module_struc.InterfaceCount
  3687                              <2> 			.scan_interface:
  3688 00001093 8B13                <2> 				mov	edx, [ebx + interface_struc.Type]
  3689 00001095 E87CFDFFFF          <2> 				call	interface.delete		;() == (edx Type)
  3690 0000109A E2F7                <2> 			loop	.scan_interface
  3691 0000109C 59                  <2> 		pop	ecx
  3692 0000109D 5B                  <2> 		pop	ebx
  3693                              <2> 			;Remove all
  3694                              <2> 		
  3695                              <2> 		;Remove Module segment
  3696 0000109E E89DF3FFFF          <2> 		call	desc.delete_lin		;() == (ebx Base, ecx Size)
  3697                              <2> 		
  3698                              <2> 		;Remove Module descriptor
  3699 000010A3 89FA                <2> 		mov	edx, edi
  3700 000010A5 E882F3FFFF          <2> 		call	desc.delete_desc		;() == (edx Selector)
  3701 000010AA 59                  <2> 	pop	ecx
  3702 000010AB 5B                  <2> 	pop	ebx
  3703 000010AC 5F                  <2> 	pop	edi
  3704 000010AD F8                  <2> 	clc
  3705 000010AE C3                  <2> 	ret
  3706                              <2> 
  3707                              <2> 		.delete_error:
  3708                              <2> 		;Not a LDT
  3709 000010AF 59                  <2> 	pop	ecx
  3710 000010B0 5B                  <2> 	pop	ebx
  3711 000010B1 5F                  <2> 	pop	edi
  3712 000010B2 F9                  <2> 	stc
  3713 000010B3 C3                  <2> 	ret
  3714                              <2> ;===============================================================================
  3715                              <2> ;
  3716                              <2> ;module.move		;(eax Selector) == (edx Source selector, ebx Target [module][selector])
  3717                              <2> ;	Move a descriptor from source module to target module
  3718                              <2> 
  3719                              <2> .move:	
  3720 000010B4 52                  <2> 	push	edx
  3721 000010B5 53                  <2> 	push	ebx
  3722                              <2> 		
  3723                              <2> 	
  3724                              <2> 		;Get source descriptor
  3725 000010B6 E877F4FFFF          <2> 		call	desc.get_desc_base	;(ebx = Base) == (dx = selector)
  3726 000010BB 722C                <2> 		jc	.move_error
  3727                              <2> 		
  3728 000010BD 89DA                <2> 		mov	edx, ebx	;Save source Base
  3729                              <2> 		
  3730 000010BF 5B                  <2> 	pop	ebx
  3731 000010C0 53                  <2> 	push	ebx
  3732                              <2> 	
  3733                              <2> 		;Get target descriptor
  3734 000010C1 E8EFF1FFFF          <2> 		call	desc.create_desc_ldt	;(eax = selector, ebx = Desc Base) == (ebx = [LDT][Selector])
  3735 000010C6 7221                <2> 		jc	.move_error
  3736                              <2> 		
  3737                              <2> 		;ebx = target
  3738                              <2> 		;edx = source
  3739 000010C8 50                  <2> 		push	eax
  3740 000010C9 9C                  <2> 		pushfd
  3741 000010CA FA                  <2> 			cli
  3742                              <2> 			;copy descriptor
  3743 000010CB 8B02                <2> 			mov	eax, [edx]
  3744 000010CD 8903                <2> 			mov	[ebx], eax
  3745 000010CF 8B4204              <2> 			mov	eax, [edx+4]
  3746 000010D2 894304              <2> 			mov	[ebx+4], eax		
  3747                              <2> 			;save DPL
  3748 000010D5 89C3                <2> 			mov	ebx, eax
  3749                              <2> 			
  3750                              <2> 			;clear original descriptor
  3751 000010D7 31C0                <2> 			xor	eax, eax
  3752 000010D9 8902                <2> 			mov	[edx], eax
  3753 000010DB 894204              <2> 			mov	[edx+4], eax		
  3754 000010DE 9D                  <2> 		popfd
  3755 000010DF 58                  <2> 		pop	eax
  3756                              <2> 		
  3757                              <2> 		;Adjust RPL in eax to DPL
  3758 000010E0 C1EB0D              <2> 		shr	ebx, 13
  3759 000010E3 63D8                <2> 		arpl	ax, bx
  3760                              <2> 		
  3761 000010E5 5B                  <2> 	pop	ebx
  3762 000010E6 5A                  <2> 	pop	edx
  3763                              <2> 	
  3764 000010E7 F8                  <2> 	clc
  3765 000010E8 C3                  <2> 	ret
  3766                              <2> 	
  3767                              <2> 	.move_error:
  3768 000010E9 5B                  <2> 	pop	ebx
  3769 000010EA 5A                  <2> 	pop	edx
  3770 000010EB F9                  <2> 	stc
  3771 000010EC C3                  <2> 	ret
  3772                              <2> 
  3773                              <2> 	
  3774                              <2> 	
  3775                              <2> ;===============================================================================
  3776                              <2> ;
  3777                              <2> ;	module.movetask	;() == (edx Source Task selector, ebx Target Module)	
  3778                              <2> ;	Move a task from source module to target modul
  3779                              <2> 
  3780                              <2> .movetask:
  3781 000010ED 50                  <2> 	push	eax
  3782 000010EE 52                  <2> 	push	edx
  3783 000010EF 53                  <2> 	push	ebx
  3784                              <2> 		
  3785                              <2> 		;Get TSS Base
  3786 000010F0 53                  <2> 		push	ebx
  3787 000010F1 E8C8F4FFFF          <2> 			call	desc.get_tss_base	;(ebx = Base) == (dx = Selector)	
  3788 000010F6 89D8                <2> 			mov	eax, ebx	;eax=TSS Base
  3789 000010F8 5B                  <2> 		pop	ebx
  3790 000010F9 7223                <2> 		jc	.movetask_error
  3791                              <2> 		
  3792                              <2> 		;Get SS0
  3793 000010FB 8B5008              <2> 		mov	edx, [eax + 8]	;ss0 in TSS
  3794                              <2> 			
  3795                              <2> 		;Move SS0
  3796 000010FE 50                  <2> 		push	eax
  3797 000010FF C1E310              <2> 			shl	ebx, 10h
  3798 00001102 83C304              <2> 			add	ebx, byte 4	;LDT bit
  3799 00001105 E8AAFFFFFF          <2> 			call	module.move		;(eax Selector) == (edx Source selector, ebx Target [module][selector])
  3800 0000110A 89C2                <2> 			mov	edx, eax		;edx = new SS0 selector
  3801 0000110C 58                  <2> 		pop	eax		
  3802 0000110D 720F                <2> 		jc	.movetask_error
  3803                              <2> 	
  3804                              <2> 		;Save new SS0 selector
  3805 0000110F 895008              <2> 		mov	[eax + 8], edx		;Save new SS0 in TSS
  3806                              <2> 		
  3807                              <2> 		;Change LDT in TSS
  3808 00001112 C1EB10              <2> 		shr	ebx, 10h
  3809 00001115 66895860            <2> 		mov	[eax + 60h], bx	;Save new LDT in TSS
  3810                              <2> 				
  3811 00001119 5B                  <2> 	pop	ebx
  3812 0000111A 5A                  <2> 	pop	edx
  3813 0000111B 58                  <2> 	pop	eax
  3814 0000111C F8                  <2> 	clc
  3815 0000111D C3                  <2> 	ret
  3816                              <2> 	
  3817                              <2> 	.movetask_error:
  3818 0000111E 5B                  <2> 	pop	ebx
  3819 0000111F 5A                  <2> 	pop	edx
  3820 00001120 58                  <2> 	pop	eax
  3821 00001121 F9                  <2> 	stc
  3822 00001122 C3                  <2> 	ret
  3823                              <1> 
  3824                              <1> 
  3825                              <1> life:
  3826 00001123 B8B241DEFC          <1> 	mov	eax, 4242424242
  3827 00001128 C3                  <1> 	ret
  3828                                  
  3829                                  
  3830                                  ;=====================
  3831                                  Multitasking:
  3832                                  ;Multitasking timer interrupt
  3833                                  global   Multitasking.interrupt
  3834                                  global   Multitasking.device_not_available
  3835                                  global   Multitasking.tss
  3836                                  
  3837                                  
  3838                                      malign 4
  3839 00001129 00<rept>            <1>  times (($$-$) % (%1)) db 0
  3840                                  
  3841                                  .interrupt:
  3842                                  %include 'Mult_Int.asm'
  3843                              <1> ;Multitasking management
  3844                              <1> 
  3845                              <1> ;occurs each timer interrupt
  3846                              <1> 
  3847                              <1> 
  3848                              <1> ;Start
  3849 0000112C 1E                  <1> 	push ds
  3850 0000112D 50                  <1> 	push eax
  3851 0000112E 53                  <1> 	push ebx
  3852 0000112F 52                  <1> 	push	edx
  3853                              <1> 		;Restore PIC
  3854 00001130 B020                <1> 	mov al, 20h	;EOI
  3855 00001132 E620                <1> 	out 20h, al
  3856                              <1> 
  3857 00001134 66B81800            <1> 	mov  ax, data_sel
  3858 00001138 8ED8                <1> 	mov  ds, ax
  3859                              <1> 
  3860 0000113A BB00204000          <1> 	mov  ebx, multitasking_struc.Head
  3861 0000113F 8B03                <1> 	mov	eax, [ebx+multitasking_struc.current]	;eax = current
  3862 00001141 8B5304              <1> 	mov	edx, [ebx+multitasking_struc.last]	;edx = last entry
  3863                              <1> 		
  3864 00001144 83FA04              <1> 	cmp	edx, byte multitasking_struc.Entry_Size	;Check number of entries
  3865 00001147 760D                <1> 	jbe	.one_task 	;One or zero tasks in the list = no task switch
  3866                              <1> 	
  3867 00001149 83C310              <1> 	add	ebx, byte multitasking_struc.HeadSize
  3868 0000114C 01C3                <1> 	add	ebx, eax
  3869                              <1> 
  3870 0000114E 0F000B              <1> 	str  [ebx + multitasking_struc.current]		;Save TR for the task we are leaving
  3871                              <1> 
  3872 00001151 E811000000          <1> 	call	.NextTask
  3873                              <1> 	
  3874                              <1> .one_task:
  3875                              <1> 
  3876                              <1> 	;Check if float state owner
  3877 00001156 0F00C8              <1> 	str	ax			;get current TSS
  3878 00001159 663B4308            <1> 	cmp	ax, [ebx + multitasking_struc.float]	;compare to current float-State owner
  3879 0000115D 7502                <1> 	jne	.dont_clear_TS
  3880 0000115F 0F06                <1> 	clts
  3881                              <1> 	.dont_clear_TS:
  3882                              <1> 	
  3883                              <1> 	;return to previous task
  3884 00001161 5A                  <1> 	pop	edx
  3885 00001162 5B                  <1> 	pop  ebx
  3886 00001163 58                  <1> 	pop  eax
  3887 00001164 1F                  <1> 	pop  ds
  3888 00001165 FB                  <1> 	sti
  3889 00001166 CF                  <1> 	iret ;Return
  3890                              <1> 
  3891                              <1> 	.NextTask
  3892                              <1> 	;eax = current(no base)
  3893                              <1> 	;edx = last(no base)
  3894                              <1> 	
  3895                              <1> 		;move to the next task
  3896 00001167 31DB                <1> 		xor	ebx, ebx
  3897 00001169 39D0                <1> 		cmp	eax, edx	;is it the last entry
  3898 0000116B 0F93C3              <1> 		setae bl
  3899 0000116E 4B                  <1> 		dec	ebx
  3900 0000116F 21D8                <1> 		and	eax, ebx
  3901 00001171 0504000000          <1> 		add	eax, multitasking_struc.Entry_Size	;eax = next entry
  3902                              <1> 		
  3903                              <1> 		;Write current task number
  3904 00001176 BB00204000          <1> 		mov	ebx, multitasking_struc.Head
  3905 0000117B 8903                <1> 		mov	[ebx+multitasking_struc.current], eax
  3906                              <1> 		
  3907                              <1> 		;Start the next task
  3908 0000117D BB10204000          <1> 		mov	ebx, multitasking_struc.Base
  3909 00001182 01C3                <1> 		add	ebx, eax			;ebx = current TSS selector
  3910 00001184 FF6BFC              <1> 		jmp far [ebx+multitasking_struc.current - 4]
  3911 00001187 C3                  <1> 	ret
  3912                              <1> 	
  3913                              <1> 
  3914                              <1> 
  3915                              <1> ;Occurs each time a task tries to use floating-point operations or MMX, SSE...
  3916                              <1> ;and the current task is not the current state owner
  3917                              <1> 
  3918                              <1> ;7: device not available
  3919                              <1> .device_not_available:
  3920                              <1> 
  3921 00001188 1E                  <1> 	push ds
  3922 00001189 52                  <1> 	push	edx
  3923 0000118A 53                  <1> 	push	ebx
  3924                              <1> 	
  3925 0000118B 66BA1800            <1> 		mov  dx, data_sel
  3926 0000118F 8EDA                <1> 		mov  ds, dx
  3927                              <1> 
  3928 00001191 BB10204000          <1> 		mov  ebx, multitasking_struc.Base
  3929 00001196 668B5308            <1> 		mov	dx, [ebx + multitasking_struc.float]	;Current state owner
  3930                              <1> 		
  3931 0000119A E83FF4FFFF          <1> 		call	desc.get_seg_base	;(ebx = Segment Base) == (dx = Selector)
  3932 0000119F 7209                <1> 		jc	.save_state
  3933 000011A1 81C300020000        <1> 		add	ebx, task_struc.Float		;Floating-point state area(512 bytes)
  3934 000011A7 0FAE03              <1> 		fxsave [ebx]
  3935                              <1> 
  3936                              <1> 		.save_state:
  3937 000011AA 0F00CA              <1> 		str	dx
  3938 000011AD E82CF4FFFF          <1> 		call	desc.get_seg_base	;(ebx = Segment Base) == (dx = Selector)
  3939 000011B2 7209                <1> 		jc	.dont_read_state	;error: TSS is illegal, shouldn't hapen
  3940 000011B4 81C300020000        <1> 		add	ebx, task_struc.Float		;Floating-point state area(512 bytes)
  3941 000011BA 0FAE0B              <1> 		fxrstor [ebx]
  3942                              <1> 		
  3943                              <1> 		.dont_read_state:
  3944 000011BD 5B                  <1> 	pop	ebx
  3945 000011BE 5A                  <1> 	pop	edx
  3946 000011BF 1F                  <1> 	pop  ds
  3947 000011C0 FB                  <1> 	sti
  3948 000011C1 CF                  <1> 	iret
  3949                              <1> 
  3950                              <1> ;;;;;;;;;;;;;;;;;;;;
  3951                                  
  3952                                  ;TSS for Idle Task
  3953                                  
  3954                                      malign 4
  3955 000011C2 00<rept>            <1>  times (($$-$) % (%1)) db 0
  3956                                  
  3957                                  .tss:
  3958                                  %include 'idle_tss.asm'
  3959 000011C4 0000                <1> .link:   dw   0    ;Task Link
  3960 000011C6 0000                <1>          dw   0    ;reserved
  3961                              <1> 
  3962 000011C8 00000000            <1>          dd   0    ;esp0
  3963 000011CC 0000                <1>          dw   0    ;ss0
  3964 000011CE 0000                <1>          dw   0    ;reserved
  3965 000011D0 00000000            <1>          dd   0    ;esp1
  3966 000011D4 0000                <1>          dw   0    ;ss1
  3967 000011D6 0000                <1>          dw   0    ;reserved
  3968 000011D8 00000000            <1>          dd   0    ;esp2
  3969 000011DC 0000                <1>          dw   0    ;ss2
  3970 000011DE 0000                <1>          dw   0    ;reserved
  3971                              <1> 
  3972 000011E0 00100000            <1>          dd   (mem_PD << 12) ;cr3/PDBR
  3973                              <1> 
  3974 000011E4 [00000000]          <1>          dd   kernel_start	;eip = start
  3975 000011E8 02020000            <1>          dd   202h    ;eflags
  3976                              <1> 
  3977 000011EC 00000000            <1>          dd   0    ;eax
  3978 000011F0 00000000            <1>          dd   0    ;ecx
  3979 000011F4 00000000            <1>          dd   0    ;edx
  3980 000011F8 00000000            <1>          dd   0    ;ebx
  3981                              <1> 
  3982 000011FC FC0F0000            <1>          dd   0FFCh ;esp
  3983 00001200 00000000            <1>          dd   0    ;ebp
  3984                              <1> 
  3985 00001204 00000000            <1>          dd   0    ;esi
  3986 00001208 00000000            <1>          dd   0    ;edi
  3987                              <1> 
  3988 0000120C 0000                <1>          dw   0    ;es
  3989 0000120E 0000                <1>          dw   0    ;    Reserved
  3990 00001210 1000                <1>          dw   kern_sel ;cs
  3991 00001212 0000                <1>          dw   0    ;    Reserved
  3992 00001214 2800                <1>          dw   Stack_sel;ss
  3993 00001216 0000                <1>          dw   0    ;    Reserved
  3994 00001218 0000                <1>          dw   0    ;ds
  3995 0000121A 0000                <1>          dw   0    ;    Reserved
  3996 0000121C 0000                <1>          dw   0    ;fs
  3997 0000121E 0000                <1>          dw   0    ;    Reserved
  3998 00001220 0000                <1>          dw   0    ;gs
  3999 00001222 0000                <1>          dw   0    ;    Reserved
  4000 00001224 0000                <1>          dw   0    ;ldt
  4001 00001226 0000                <1>          dw   0    ;    Reserved
  4002                              <1> 
  4003 00001228 0000                <1>          dw   0    ;trap(bit0)
  4004 0000122A 6800                <1>          dw   (.iobase - .tss)    ;IO map Base Address
  4005                              <1> .iobase:
  4006                              <1> 
  4007                              <1> ;error checking
  4008                              <1> times    68h-(.iobase-.tss)  nop
  4009                              <1> times    (.iobase-.tss)-68h  nop
  4010                              <1> ;both should result in 0 bytes of nop
  4011                                  
  4012                                  
  4013                                  ;Idle Code
  4014                                  
  4015                                      malign 4
  4016                              <1>  times (($$-$) % (%1)) db 0
  4017                                  
  4018                                  .idle:
  4019                                  %include 'idle.asm'
  4020                              <1> ;Idle task
  4021                              <1> 
  4022                              <1> ;This is what I call idle...
  4023                              <1> 
  4024                              <1> .idle_loop:
  4025 0000122C F4                  <1> 	hlt
  4026 0000122D EBFD                <1> 	jmp	.idle_loop
  4027                                  
  4028                                  
  4029                                  ;=====================
  4030                                  ;Interrupt managers
  4031                                  ;
  4032                                  ;Exception interrupt 0-1F
  4033                                  ;IRQ-Interrupt		 20-2F	(20 = timer, multitasking)
  4034                                      malign 4
  4035 0000122F 00                  <1>  times (($$-$) % (%1)) db 0
  4036                                  Interrupt:
  4037                                  %include 'Interrupt.asm'
  4038                              <1> ;=====================
  4039                              <1> ;Interrupt handler
  4040                              <1> ;
  4041                              <1> ;	 0-1F	Exceptions
  4042                              <1> ;	20-2F	IRQ 0-F
  4043                              <1> ;	30-FF	Interrupt 30-FF
  4044                              <1> 
  4045                              <1> 
  4046                              <1> ;==================================
  4047                              <1> ; Exceptions
  4048                              <1> ;
  4049                              <1> %macro exception 1
  4050                              <1> global   Interrupt.exception%1
  4051                              <1> .exception%1:
  4052                              <1> 	mov	eax, %1h
  4053                              <1> 	jmp	.exception
  4054                              <1> %endmacro
  4055                              <1> 
  4056                              <1> .exception:
  4057                              <1> 	;Fix ds
  4058 00001230 668CCA              <1> 	mov	dx, cs
  4059 00001233 8EDA                <1> 	mov	ds, dx
  4060                              <1> 	
  4061                              <1> 	Print	.t_exc
  4062 00001235 60                  <2>  pusha
  4063 00001236 BA[B7120000]        <2>  mov edx, %1
  4064 0000123B E8F7EDFFFF          <2>  call RS232.Print
  4065 00001240 61                  <2>  popa
  4066                              <1> 
  4067                              <1> 	PrintHex	eax, 2	
  4068 00001241 60                  <2>  pusha
  4069 00001242 89C0                <2>  mov eax, %1
  4070 00001244 B902000000          <2>  mov ecx, %2
  4071 00001249 E816EEFFFF          <2>  call RS232.PrintHex
  4072 0000124E 61                  <2>  popa
  4073                              <1> 	
  4074                              <1> 	Print	.t_err
  4075 0000124F 60                  <2>  pusha
  4076 00001250 BA[CC120000]        <2>  mov edx, %1
  4077 00001255 E8DDEDFFFF          <2>  call RS232.Print
  4078 0000125A 61                  <2>  popa
  4079                              <1> 
  4080 0000125B 58                  <1> 	pop	eax
  4081                              <1> 	PrintHex eax, 8
  4082 0000125C 60                  <2>  pusha
  4083 0000125D 89C0                <2>  mov eax, %1
  4084 0000125F B908000000          <2>  mov ecx, %2
  4085 00001264 E8FBEDFFFF          <2>  call RS232.PrintHex
  4086 00001269 61                  <2>  popa
  4087                              <1> 
  4088                              <1> 	Print	.t_eip
  4089 0000126A 60                  <2>  pusha
  4090 0000126B BA[E9120000]        <2>  mov edx, %1
  4091 00001270 E8C2EDFFFF          <2>  call RS232.Print
  4092 00001275 61                  <2>  popa
  4093                              <1> 
  4094 00001276 58                  <1> 	pop	eax
  4095                              <1> 	PrintHex eax, 8
  4096 00001277 60                  <2>  pusha
  4097 00001278 89C0                <2>  mov eax, %1
  4098 0000127A B908000000          <2>  mov ecx, %2
  4099 0000127F E8E0EDFFFF          <2>  call RS232.PrintHex
  4100 00001284 61                  <2>  popa
  4101                              <1> 	
  4102                              <1> 	Print	.t_cs
  4103 00001285 60                  <2>  pusha
  4104 00001286 BA[00130000]        <2>  mov edx, %1
  4105 0000128B E8A7EDFFFF          <2>  call RS232.Print
  4106 00001290 61                  <2>  popa
  4107                              <1> 
  4108 00001291 58                  <1> 	pop	eax
  4109                              <1> 	PrintHex eax, 4
  4110 00001292 60                  <2>  pusha
  4111 00001293 89C0                <2>  mov eax, %1
  4112 00001295 B904000000          <2>  mov ecx, %2
  4113 0000129A E8C5EDFFFF          <2>  call RS232.PrintHex
  4114 0000129F 61                  <2>  popa
  4115                              <1> 	
  4116                              <1> 	Print	.t_end
  4117 000012A0 60                  <2>  pusha
  4118 000012A1 BA[17130000]        <2>  mov edx, %1
  4119 000012A6 E88CEDFFFF          <2>  call RS232.Print
  4120 000012AB 61                  <2>  popa
  4121                              <1> 
  4122 000012AC FB                  <1> 	sti
  4123                              <1> 	
  4124                              <1> 	;Fix ds
  4125 000012AD 66B81800            <1> 	mov	ax, data_sel
  4126 000012B1 8ED8                <1> 	mov	ds, ax
  4127                              <1> 	
  4128 000012B3 FA                  <1> 	cli
  4129                              <1> 	.everlasting:
  4130                              <1> 		
  4131                              <1> 		;Stop current task
  4132                              <1> 	;	str	ax
  4133                              <1> 	;	call	mult.remove	;() == (ax = TSS Selector)
  4134                              <1> 
  4135 000012B4 F4                  <1> 	hlt
  4136 000012B5 EBFD                <1> 	jmp	.everlasting
  4137                              <1> 
  4138                              <1> .t_exc:
  4139 000012B7 0A0A0A457863657074- <1> 	db	10, 10, 10, 'Exception error: ', 0
  4140 000012C0 696F6E206572726F72- <1>
  4141 000012C9 3A2000              <1>
  4142                              <1> .t_err:
  4143 000012CC 202020202020202020- <1> 	db	'          ', 10, '     Error code: ', 0
  4144 000012D5 200A20202020204572- <1>
  4145 000012DE 726F7220636F64653A- <1>
  4146 000012E7 2000                <1>
  4147                              <1> .t_eip:
  4148 000012E9 202020200A20202020- <1> 	db	'    ', 10, '            EIP: ', 0
  4149 000012F2 202020202020202045- <1>
  4150 000012FB 49503A2000          <1>
  4151                              <1> .t_cs:
  4152 00001300 202020200A20202020- <1> 	db	'    ', 10, '             CS: ', 0
  4153 00001309 202020202020202020- <1>
  4154 00001312 43533A2000          <1>
  4155                              <1> .t_end:
  4156 00001317 20202020202020200A- <1> 	db	'        ', 10, 10, 'Interrupts disabled, System halted', 0
  4157 00001320 0A496E746572727570- <1>
  4158 00001329 74732064697361626C- <1>
  4159 00001332 65642C205379737465- <1>
  4160 0000133B 6D2068616C74656400  <1>
  4161                              <1> 	
  4162                              <1> 	
  4163                              <1> 	
  4164                              <1>     exception 00
  4165                              <2> global Interrupt.exception%1
  4166                              <2> .exception%1:
  4167 00001344 B800000000          <2>  mov eax, %1h
  4168 00001349 E9E2FEFFFF          <2>  jmp .exception
  4169                              <1>     exception 01
  4170                              <2> global Interrupt.exception%1
  4171                              <2> .exception%1:
  4172 0000134E B801000000          <2>  mov eax, %1h
  4173 00001353 E9D8FEFFFF          <2>  jmp .exception
  4174                              <1>     exception 02
  4175                              <2> global Interrupt.exception%1
  4176                              <2> .exception%1:
  4177 00001358 B802000000          <2>  mov eax, %1h
  4178 0000135D E9CEFEFFFF          <2>  jmp .exception
  4179                              <1>     exception 03
  4180                              <2> global Interrupt.exception%1
  4181                              <2> .exception%1:
  4182 00001362 B803000000          <2>  mov eax, %1h
  4183 00001367 E9C4FEFFFF          <2>  jmp .exception
  4184                              <1>     exception 04
  4185                              <2> global Interrupt.exception%1
  4186                              <2> .exception%1:
  4187 0000136C B804000000          <2>  mov eax, %1h
  4188 00001371 E9BAFEFFFF          <2>  jmp .exception
  4189                              <1>     exception 05
  4190                              <2> global Interrupt.exception%1
  4191                              <2> .exception%1:
  4192 00001376 B805000000          <2>  mov eax, %1h
  4193 0000137B E9B0FEFFFF          <2>  jmp .exception
  4194                              <1>     exception 06
  4195                              <2> global Interrupt.exception%1
  4196                              <2> .exception%1:
  4197 00001380 B806000000          <2>  mov eax, %1h
  4198 00001385 E9A6FEFFFF          <2>  jmp .exception
  4199                              <1>     exception 07
  4200                              <2> global Interrupt.exception%1
  4201                              <2> .exception%1:
  4202 0000138A B807000000          <2>  mov eax, %1h
  4203 0000138F E99CFEFFFF          <2>  jmp .exception
  4204                              <1>     exception 08
  4205                              <2> global Interrupt.exception%1
  4206                              <2> .exception%1:
  4207 00001394 B808000000          <2>  mov eax, %1h
  4208 00001399 E992FEFFFF          <2>  jmp .exception
  4209                              <1>     exception 09
  4210                              <2> global Interrupt.exception%1
  4211                              <2> .exception%1:
  4212 0000139E B809000000          <2>  mov eax, %1h
  4213 000013A3 E988FEFFFF          <2>  jmp .exception
  4214                              <1>     exception 0A
  4215                              <2> global Interrupt.exception%1
  4216                              <2> .exception%1:
  4217 000013A8 B80A000000          <2>  mov eax, %1h
  4218 000013AD E97EFEFFFF          <2>  jmp .exception
  4219                              <1>     exception 0B
  4220                              <2> global Interrupt.exception%1
  4221                              <2> .exception%1:
  4222 000013B2 B80B000000          <2>  mov eax, %1h
  4223 000013B7 E974FEFFFF          <2>  jmp .exception
  4224                              <1>     exception 0C
  4225                              <2> global Interrupt.exception%1
  4226                              <2> .exception%1:
  4227 000013BC B80C000000          <2>  mov eax, %1h
  4228 000013C1 E96AFEFFFF          <2>  jmp .exception
  4229                              <1>     exception 0D
  4230                              <2> global Interrupt.exception%1
  4231                              <2> .exception%1:
  4232 000013C6 B80D000000          <2>  mov eax, %1h
  4233 000013CB E960FEFFFF          <2>  jmp .exception
  4234                              <1>     exception 0E
  4235                              <2> global Interrupt.exception%1
  4236                              <2> .exception%1:
  4237 000013D0 B80E000000          <2>  mov eax, %1h
  4238 000013D5 E956FEFFFF          <2>  jmp .exception
  4239                              <1>     exception 0F
  4240                              <2> global Interrupt.exception%1
  4241                              <2> .exception%1:
  4242 000013DA B80F000000          <2>  mov eax, %1h
  4243 000013DF E94CFEFFFF          <2>  jmp .exception
  4244                              <1>     exception 10
  4245                              <2> global Interrupt.exception%1
  4246                              <2> .exception%1:
  4247 000013E4 B810000000          <2>  mov eax, %1h
  4248 000013E9 E942FEFFFF          <2>  jmp .exception
  4249                              <1>     exception 11
  4250                              <2> global Interrupt.exception%1
  4251                              <2> .exception%1:
  4252 000013EE B811000000          <2>  mov eax, %1h
  4253 000013F3 E938FEFFFF          <2>  jmp .exception
  4254                              <1>     exception 12
  4255                              <2> global Interrupt.exception%1
  4256                              <2> .exception%1:
  4257 000013F8 B812000000          <2>  mov eax, %1h
  4258 000013FD E92EFEFFFF          <2>  jmp .exception
  4259                              <1>     exception 13
  4260                              <2> global Interrupt.exception%1
  4261                              <2> .exception%1:
  4262 00001402 B813000000          <2>  mov eax, %1h
  4263 00001407 E924FEFFFF          <2>  jmp .exception
  4264                              <1>     exception 14
  4265                              <2> global Interrupt.exception%1
  4266                              <2> .exception%1:
  4267 0000140C B814000000          <2>  mov eax, %1h
  4268 00001411 E91AFEFFFF          <2>  jmp .exception
  4269                              <1>     exception 15
  4270                              <2> global Interrupt.exception%1
  4271                              <2> .exception%1:
  4272 00001416 B815000000          <2>  mov eax, %1h
  4273 0000141B E910FEFFFF          <2>  jmp .exception
  4274                              <1>     exception 16
  4275                              <2> global Interrupt.exception%1
  4276                              <2> .exception%1:
  4277 00001420 B816000000          <2>  mov eax, %1h
  4278 00001425 E906FEFFFF          <2>  jmp .exception
  4279                              <1>     exception 17
  4280                              <2> global Interrupt.exception%1
  4281                              <2> .exception%1:
  4282 0000142A B817000000          <2>  mov eax, %1h
  4283 0000142F E9FCFDFFFF          <2>  jmp .exception
  4284                              <1>     exception 18
  4285                              <2> global Interrupt.exception%1
  4286                              <2> .exception%1:
  4287 00001434 B818000000          <2>  mov eax, %1h
  4288 00001439 E9F2FDFFFF          <2>  jmp .exception
  4289                              <1>     exception 19
  4290                              <2> global Interrupt.exception%1
  4291                              <2> .exception%1:
  4292 0000143E B819000000          <2>  mov eax, %1h
  4293 00001443 E9E8FDFFFF          <2>  jmp .exception
  4294                              <1>     exception 1A
  4295                              <2> global Interrupt.exception%1
  4296                              <2> .exception%1:
  4297 00001448 B81A000000          <2>  mov eax, %1h
  4298 0000144D E9DEFDFFFF          <2>  jmp .exception
  4299                              <1>     exception 1B
  4300                              <2> global Interrupt.exception%1
  4301                              <2> .exception%1:
  4302 00001452 B81B000000          <2>  mov eax, %1h
  4303 00001457 E9D4FDFFFF          <2>  jmp .exception
  4304                              <1>     exception 1C
  4305                              <2> global Interrupt.exception%1
  4306                              <2> .exception%1:
  4307 0000145C B81C000000          <2>  mov eax, %1h
  4308 00001461 E9CAFDFFFF          <2>  jmp .exception
  4309                              <1>     exception 1D
  4310                              <2> global Interrupt.exception%1
  4311                              <2> .exception%1:
  4312 00001466 B81D000000          <2>  mov eax, %1h
  4313 0000146B E9C0FDFFFF          <2>  jmp .exception
  4314                              <1>     exception 1E
  4315                              <2> global Interrupt.exception%1
  4316                              <2> .exception%1:
  4317 00001470 B81E000000          <2>  mov eax, %1h
  4318 00001475 E9B6FDFFFF          <2>  jmp .exception
  4319                              <1>     exception 1F
  4320                              <2> global Interrupt.exception%1
  4321                              <2> .exception%1:
  4322 0000147A B81F000000          <2>  mov eax, %1h
  4323 0000147F E9ACFDFFFF          <2>  jmp .exception
  4324                              <1> 
  4325                              <1> ;==================================
  4326                              <1> ; IRQs
  4327                              <1> ; 20-2F
  4328                              <1> ;
  4329                              <1> %macro IRQ 1
  4330                              <1> global   Interrupt.IRQ%1
  4331                              <1> .IRQ%1:
  4332                              <1> 	pusha
  4333                              <1> 	mov	eax, 0%1h
  4334                              <1> 	jmp	.IRQ_handle
  4335                              <1> %endmacro
  4336                              <1> 
  4337                              <1> .IRQ_handle:
  4338                              <1> 	PrintByte ''
  4339 00001484 60                  <2>  pusha
  4340 00001485 B0A3                <2>  mov al, %1
  4341 00001487 E8BAEBFFFF          <2>  call RS232.PrintByte
  4342 0000148C 61                  <2>  popa
  4343                              <1> 	;Look up in table
  4344                              <1> 	;Start task
  4345                              <1> 	;send EOI to PIC
  4346 0000148D 61                  <1> 	popa
  4347 0000148E CF                  <1> 	iret
  4348                              <1> 
  4349                              <1> IRQ 0
  4350                              <2> global Interrupt.IRQ%1
  4351                              <2> .IRQ%1:
  4352 0000148F 60                  <2>  pusha
  4353 00001490 B800000000          <2>  mov eax, 0%1h
  4354 00001495 EBED                <2>  jmp .IRQ_handle
  4355                              <1> IRQ 1
  4356                              <2> global Interrupt.IRQ%1
  4357                              <2> .IRQ%1:
  4358 00001497 60                  <2>  pusha
  4359 00001498 B801000000          <2>  mov eax, 0%1h
  4360 0000149D EBE5                <2>  jmp .IRQ_handle
  4361                              <1> IRQ 2
  4362                              <2> global Interrupt.IRQ%1
  4363                              <2> .IRQ%1:
  4364 0000149F 60                  <2>  pusha
  4365 000014A0 B802000000          <2>  mov eax, 0%1h
  4366 000014A5 EBDD                <2>  jmp .IRQ_handle
  4367                              <1> IRQ 3
  4368                              <2> global Interrupt.IRQ%1
  4369                              <2> .IRQ%1:
  4370 000014A7 60                  <2>  pusha
  4371 000014A8 B803000000          <2>  mov eax, 0%1h
  4372 000014AD EBD5                <2>  jmp .IRQ_handle
  4373                              <1> IRQ 4
  4374                              <2> global Interrupt.IRQ%1
  4375                              <2> .IRQ%1:
  4376 000014AF 60                  <2>  pusha
  4377 000014B0 B804000000          <2>  mov eax, 0%1h
  4378 000014B5 EBCD                <2>  jmp .IRQ_handle
  4379                              <1> IRQ 5
  4380                              <2> global Interrupt.IRQ%1
  4381                              <2> .IRQ%1:
  4382 000014B7 60                  <2>  pusha
  4383 000014B8 B805000000          <2>  mov eax, 0%1h
  4384 000014BD EBC5                <2>  jmp .IRQ_handle
  4385                              <1> IRQ 6
  4386                              <2> global Interrupt.IRQ%1
  4387                              <2> .IRQ%1:
  4388 000014BF 60                  <2>  pusha
  4389 000014C0 B806000000          <2>  mov eax, 0%1h
  4390 000014C5 EBBD                <2>  jmp .IRQ_handle
  4391                              <1> IRQ 7
  4392                              <2> global Interrupt.IRQ%1
  4393                              <2> .IRQ%1:
  4394 000014C7 60                  <2>  pusha
  4395 000014C8 B807000000          <2>  mov eax, 0%1h
  4396 000014CD EBB5                <2>  jmp .IRQ_handle
  4397                              <1> IRQ 8
  4398                              <2> global Interrupt.IRQ%1
  4399                              <2> .IRQ%1:
  4400 000014CF 60                  <2>  pusha
  4401 000014D0 B808000000          <2>  mov eax, 0%1h
  4402 000014D5 EBAD                <2>  jmp .IRQ_handle
  4403                              <1> IRQ 9
  4404                              <2> global Interrupt.IRQ%1
  4405                              <2> .IRQ%1:
  4406 000014D7 60                  <2>  pusha
  4407 000014D8 B809000000          <2>  mov eax, 0%1h
  4408 000014DD EBA5                <2>  jmp .IRQ_handle
  4409                              <1> IRQ A
  4410                              <2> global Interrupt.IRQ%1
  4411                              <2> .IRQ%1:
  4412 000014DF 60                  <2>  pusha
  4413 000014E0 B80A000000          <2>  mov eax, 0%1h
  4414 000014E5 EB9D                <2>  jmp .IRQ_handle
  4415                              <1> IRQ B
  4416                              <2> global Interrupt.IRQ%1
  4417                              <2> .IRQ%1:
  4418 000014E7 60                  <2>  pusha
  4419 000014E8 B80B000000          <2>  mov eax, 0%1h
  4420 000014ED EB95                <2>  jmp .IRQ_handle
  4421                              <1> IRQ C
  4422                              <2> global Interrupt.IRQ%1
  4423                              <2> .IRQ%1:
  4424 000014EF 60                  <2>  pusha
  4425 000014F0 B80C000000          <2>  mov eax, 0%1h
  4426 000014F5 EB8D                <2>  jmp .IRQ_handle
  4427                              <1> IRQ D
  4428                              <2> global Interrupt.IRQ%1
  4429                              <2> .IRQ%1:
  4430 000014F7 60                  <2>  pusha
  4431 000014F8 B80D000000          <2>  mov eax, 0%1h
  4432 000014FD EB85                <2>  jmp .IRQ_handle
  4433                              <1> IRQ E
  4434                              <2> global Interrupt.IRQ%1
  4435                              <2> .IRQ%1:
  4436 000014FF 60                  <2>  pusha
  4437 00001500 B80E000000          <2>  mov eax, 0%1h
  4438 00001505 E97AFFFFFF          <2>  jmp .IRQ_handle
  4439                              <1> IRQ F
  4440                              <2> global Interrupt.IRQ%1
  4441                              <2> .IRQ%1:
  4442 0000150A 60                  <2>  pusha
  4443 0000150B B80F000000          <2>  mov eax, 0%1h
  4444 00001510 E96FFFFFFF          <2>  jmp .IRQ_handle
  4445                              <1> 
  4446                              <1> 
  4447                              <1> 
  4448                              <1> ;==================================
  4449                              <1> ; Interrupts
  4450                              <1> ; 30-FF
  4451                              <1> ;
  4452                              <1> global	Interrupt.Interrupts
  4453                              <1> .Interrupts:
  4454 00001515 60                  <1> 	pusha
  4455                              <1> 	
  4456                              <1> 	PrintByte '$'
  4457 00001516 60                  <2>  pusha
  4458 00001517 B024                <2>  mov al, %1
  4459 00001519 E828EBFFFF          <2>  call RS232.PrintByte
  4460 0000151E 61                  <2>  popa
  4461                              <1> 	;Look up in table
  4462                              <1> 	;Start task
  4463 0000151F 61                  <1> 	popa
  4464 00001520 CF                  <1> 	iret
  4465                              <1> 
